<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mount Improbable - MOMI</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            overflow: hidden;
        }

        #container {
            width: 100vw;
            height: 100vh;
            display: flex;
        }

        #canvas-container {
            flex: 1;
            position: relative;
        }

        #controls {
            width: 300px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            overflow-y: auto;
            box-shadow: -2px 0 10px rgba(0, 0, 0, 0.2);
        }

        h1 {
            color: #1e3c72;
            font-size: 24px;
            margin-bottom: 10px;
        }

        h2 {
            color: #2a5298;
            font-size: 18px;
            margin-top: 20px;
            margin-bottom: 10px;
        }

        .info {
            background: #e8f4f8;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 15px;
            font-size: 12px;
            line-height: 1.6;
        }

        .legend {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .legend-box {
            width: 30px;
            height: 20px;
            border: 1px solid #333;
        }

        .legend-box.female {
            background: #ff69b4;
            border-radius: 5px;
        }

        .legend-box.male {
            background: #4169e1;
        }

        .person-info {
            background: #f0f0f0;
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            font-size: 13px;
        }

        .person-info h3 {
            color: #1e3c72;
            margin-bottom: 5px;
            font-size: 14px;
        }

        .person-info p {
            margin: 3px 0;
        }

        button {
            background: #2a5298;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 10px;
            width: 100%;
        }

        button:hover {
            background: #1e3c72;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px 40px;
            border-radius: 10px;
        }

        #title-overlay {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 36px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
            z-index: 10;
        }
        
        #title-overlay a {
            color: white;
            text-decoration: none;
            cursor: pointer;
            transition: color 0.3s;
        }
        
        #title-overlay a:hover {
            color: #00ffaa;
            text-shadow: 0 0 10px rgba(0, 255, 170, 0.5);
        }
        
        .event-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            pointer-events: none;
            z-index: 1000;
            font-size: 13px;
            max-width: 250px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
            border: 2px solid #ffaa00;
        }
        
        .event-tooltip h4 {
            margin: 0 0 5px 0;
            font-size: 14px;
        }
        
        .event-tooltip p {
            margin: 3px 0;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="canvas-container">
            <div id="title-overlay"><a href="https://en.wikipedia.org/wiki/Climbing_Mount_Improbable" target="_blank">Mount Improbable</a></div>
            <div id="loading">Loading 3D Visualization...</div>
        </div>
        <div id="controls">
            <h1>MOMI</h1>
            <p style="color: #666; font-size: 12px; margin-bottom: 15px;">
                Motives of Mount Improbable
            </p>

            <div class="info">
                <strong>3D Family Tree - Mount Improbable</strong><br>
                Y-axis: Time (↑ top = present, bottom = past)<br>
                X & Z axes: Family positioning<br>
                Height: Lifespan/Age<br>
                <em>Family tree grows upward through time</em>
            </div>

            <h2>Legend</h2>
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-box female"></div>
                    <span>Female (rounded rectangle)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-box male"></div>
                    <span>Male (rectangle)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-box" style="background: #888888;"></div>
                    <span>Deceased (grey, transparent)</span>
                </div>
            </div>

            <h2>Controls</h2>
            <div class="info">
                <strong>Mouse:</strong><br>
                • Left click + drag: Rotate view<br>
                • Right click + drag: Pan<br>
                • Scroll: Zoom in/out<br>
                • Click on person: View details
            </div>

            <button id="reset-camera">Reset Camera View</button>
            <button id="toggle-perspective" style="background: #ff6b35; margin-top: 5px;">Disable Perspective</button>
            <button id="toggle-life-events" style="background: #9c27b0; margin-top: 5px;">Hide Life Events</button>
            <button id="toggle-genomes" style="background: #2196f3; margin-top: 5px;">Show Diploid Genomes</button>

            <h2>Family Selection</h2>
            <div style="display: flex; flex-direction: column; gap: 5px; margin-bottom: 15px;">
                <button id="select-all" style="background: #4CAF50;">Show All Families</button>
                <button id="select-smith">Focus Smith Family</button>
                <button id="select-chen">Focus Chen Family</button>
            </div>

            <div id="family-info"></div>
            <div id="person-details"></div>

            <h2>Families</h2>
            <div class="info">
                <strong>2 Families, 3 Generations Each:</strong><br>
                • Smith Family (left, 9 members)<br>
                • Chen Family (right, 8 members)<br>
                • Shows evolutionary progression<br>
                • All births biologically spaced (9+ months)<br>
                <em>Click buttons to focus, or click gestation stacks for trimester info</em>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>

        // Configuration
        const PERSON_WIDTH = 1;
        const PERSON_DEPTH = 1;
        const YEAR_SCALE = 0.1; // 1 year = 0.1 units in 3D space
        const CURRENT_YEAR = 2025;
        const OLDEST_YEAR = 1930; // Reference point for the bottom of the timeline
        
        // Evolutionary perspective - fictional origin point for visualization
        const ORIGIN_YEAR = OLDEST_YEAR - 20; // 20 years before oldest person (1910)
        const VANISHING_POINT = { x: 0, z: 0 }; // All lineages converge here
        let perspectiveEnabled = true; // Toggle for perspective view
        let lifeEventsVisible = true; // Toggle for life events visibility

        // Scene setup
        let scene, camera, renderer, controls;
        let selectedPerson = null;
        let selectedFamily = null; // 'smith', 'chen', or null for all
        const personMeshes = new Map(); // Map person ID to mesh
        const conceptionLines = []; // Store conception line objects
        const lifeEventMarkers = []; // Store life event markers and lines
        const genomeVisualizations = []; // Store genome visualizations
        let genomesVisible = false; // Toggle for genome visibility
        
        // Family member IDs (populated from API)
        let familyMembers = {};
        
        // Apply perspective convergence to X/Z positions
        // Linear interpolation: at CURRENT_YEAR = full position, at ORIGIN_YEAR = vanishing point
        function applyPerspective(x, z, year) {
            if (!perspectiveEnabled) {
                // No perspective - return original positions
                return { x: x, z: z, scale: 1.0 };
            }
            
            // Calculate how far we are from origin to present
            const totalYears = CURRENT_YEAR - ORIGIN_YEAR;
            const yearFromOrigin = year - ORIGIN_YEAR;
            
            // Scale factor: 0 at origin, 1 at present
            const scale = Math.max(0, Math.min(1, yearFromOrigin / totalYears));
            
            // Positions converge toward vanishing point as we go back in time
            const perspectiveX = VANISHING_POINT.x + (x - VANISHING_POINT.x) * scale;
            const perspectiveZ = VANISHING_POINT.z + (z - VANISHING_POINT.z) * scale;
            
            return { x: perspectiveX, z: perspectiveZ, scale };
        }

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a2332);
            scene.fog = new THREE.Fog(0x1a2332, 10, 50);

            // Camera
            const container = document.getElementById('canvas-container');
            camera = new THREE.PerspectiveCamera(
                60,
                container.clientWidth / container.clientHeight,
                0.1,
                1000
            );
            camera.position.set(15, 10, 15);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);

            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 5;
            controls.maxDistance = 50;

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -20;
            directionalLight.shadow.camera.right = 20;
            directionalLight.shadow.camera.top = 20;
            directionalLight.shadow.camera.bottom = -20;
            scene.add(directionalLight);

            // Grid helper at bottom (past)
            const gridHelper = new THREE.GridHelper(30, 30, 0x444444, 0x222222);
            gridHelper.position.y = 0;
            scene.add(gridHelper);

            // Add grid at present (top)
            addPresentGrid();

            // Axes helper at origin of life (when perspective enabled) or at 0,0,0
            const axesHelper = new THREE.AxesHelper(5);
            if (perspectiveEnabled) {
                const originHeight = (ORIGIN_YEAR - OLDEST_YEAR) * YEAR_SCALE;
                axesHelper.position.set(VANISHING_POINT.x, originHeight, VANISHING_POINT.z);
            }
            scene.add(axesHelper);

            // Add axis labels
            addAxisLabels();
            
            // Add visible Y-axis with year markings
            addTimeAxis();

            // Handle window resize
            window.addEventListener('resize', onWindowResize);

            // Mouse click for selection
            renderer.domElement.addEventListener('click', onMouseClick);

            // Reset camera button
            document.getElementById('reset-camera').addEventListener('click', resetCamera);
            
            // Perspective toggle button
            document.getElementById('toggle-perspective').addEventListener('click', togglePerspective);
            
            // Life events toggle button
            document.getElementById('toggle-life-events').addEventListener('click', toggleLifeEvents);
            
            // Genome toggle button
            document.getElementById('toggle-genomes').addEventListener('click', toggleGenomes);
            
            // Family selection buttons
            document.getElementById('select-all').addEventListener('click', () => selectFamily(null));
            document.getElementById('select-smith').addEventListener('click', () => selectFamily('smith'));
            document.getElementById('select-chen').addEventListener('click', () => selectFamily('chen'));
            
            // Mouse move for hover tooltips
            renderer.domElement.addEventListener('mousemove', onMouseMove);

            // Hide loading message
            document.getElementById('loading').style.display = 'none';
        }

        function addAxisLabels() {
            const loader = new THREE.FontLoader();
            // For simplicity, using sprites with text textures
            const createTextLabel = (text, position, color = 0xffffff) => {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 512;
                canvas.height = 128;
                context.fillStyle = `#${color.toString(16).padStart(6, '0')}`;
                context.font = 'Bold 48px Arial';
                context.textAlign = 'center';
                context.fillText(text, 256, 80);

                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.position.copy(position);
                sprite.scale.set(4, 1, 1);
                scene.add(sprite);
            };

            // Y-axis label at "now" (present)
            const presentHeight = (CURRENT_YEAR - OLDEST_YEAR) * YEAR_SCALE;
            createTextLabel('Time (Y) ↑ NOW', new THREE.Vector3(0, presentHeight + 1, 0), 0x00ff00);
            
            // X and Z axis labels
            createTextLabel('X (Family Position)', new THREE.Vector3(8, 0, 0), 0xff0000);
            createTextLabel('Z (Generations)', new THREE.Vector3(0, 0, 8), 0x0000ff);
        }

        function addPresentGrid() {
            // Calculate height of present (2025)
            const presentHeight = (CURRENT_YEAR - OLDEST_YEAR) * YEAR_SCALE;
            
            // Create a semi-transparent grid at the present level
            const gridHelper = new THREE.GridHelper(30, 30, 0x00ff88, 0x00aa66);
            gridHelper.position.y = presentHeight;
            scene.add(gridHelper);
            
            // Add a glowing plane to make it more visible
            const planeGeometry = new THREE.PlaneGeometry(30, 30);
            const planeMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00ffaa,
                transparent: true,
                opacity: 0.1,
                side: THREE.DoubleSide
            });
            const plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.rotation.x = Math.PI / 2;
            plane.position.y = presentHeight;
            scene.add(plane);
            
            // Add a border/outline for the present plane
            const edgesGeometry = new THREE.EdgesGeometry(planeGeometry);
            const edgesMaterial = new THREE.LineBasicMaterial({ 
                color: 0x00ffff,
                linewidth: 2
            });
            const edges = new THREE.LineSegments(edgesGeometry, edgesMaterial);
            edges.rotation.x = Math.PI / 2;
            edges.position.y = presentHeight;
            scene.add(edges);
            
            // Add "BIOSPHERE, NOW" label
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 512;
            canvas.height = 128;
            context.fillStyle = '#00ffff';
            context.font = 'Bold 48px Arial';
            context.textAlign = 'center';
            context.fillText('BIOSPHERE, NOW', 256, 80);

            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.set(0, presentHeight + 0.5, 0);
            sprite.scale.set(6, 1.5, 1);
            scene.add(sprite);
        }

        function addTimeAxis() {
            // Base position for axis (will be adjusted with perspective)
            const baseX = -6;
            const baseZ = -6;
            
            // Create vertical axis line - bottom (origin/past) to top (present)
            const presentHeight = (CURRENT_YEAR - OLDEST_YEAR) * YEAR_SCALE;
            const bottomHeight = perspectiveEnabled ? (ORIGIN_YEAR - OLDEST_YEAR) * YEAR_SCALE : 0;
            
            // Apply perspective to axis endpoints
            const bottomYear = perspectiveEnabled ? ORIGIN_YEAR : OLDEST_YEAR;
            const bottomPos = applyPerspective(baseX, baseZ, bottomYear);
            const topPos = applyPerspective(baseX, baseZ, CURRENT_YEAR);
            
            const axisPoints = [
                new THREE.Vector3(bottomPos.x, bottomHeight, bottomPos.z),
                new THREE.Vector3(topPos.x, presentHeight, topPos.z)
            ];
            const axisGeometry = new THREE.BufferGeometry().setFromPoints(axisPoints);
            const axisMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 });
            const axisLine = new THREE.Line(axisGeometry, axisMaterial);
            scene.add(axisLine);

            // Add year labels every 10 years
            const createYearLabel = (year, yPosition) => {
                // Apply perspective to label position
                const labelPos = applyPerspective(baseX - 1, baseZ, year);
                
                // Scale based on perspective - older years appear smaller
                const scaleFactor = perspectiveEnabled ? labelPos.scale : 1.0;
                
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 128;
                canvas.height = 64;
                context.fillStyle = '#ffffff';
                context.font = 'Bold 32px Arial';
                context.textAlign = 'right';
                context.fillText(year.toString(), 120, 45);

                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.position.set(labelPos.x, yPosition, labelPos.z);
                sprite.scale.set(1.5 * scaleFactor, 0.75 * scaleFactor, 1);
                scene.add(sprite);
                
                // Add tick mark with perspective
                const tickPos = applyPerspective(baseX, baseZ, year);
                const tickEndPos = applyPerspective(baseX - 0.3, baseZ, year);
                
                const tickPoints = [
                    new THREE.Vector3(tickPos.x, yPosition, tickPos.z),
                    new THREE.Vector3(tickEndPos.x, yPosition, tickEndPos.z)
                ];
                const tickGeometry = new THREE.BufferGeometry().setFromPoints(tickPoints);
                const tickMaterial = new THREE.LineBasicMaterial({ color: 0xffffff });
                const tick = new THREE.Line(tickGeometry, tickMaterial);
                scene.add(tick);
            };

            // Calculate year range
            const yearsToShow = [1940, 1950, 1960, 1970, 1980, 1990, 2000, 2010, 2020, CURRENT_YEAR];
            
            yearsToShow.forEach(year => {
                const yPosition = (year - OLDEST_YEAR) * YEAR_SCALE;
                createYearLabel(year, yPosition);
            });
        }

        function createRoundedBoxGeometry(width, height, depth, radius, smoothness) {
            // Create a shape for rounded rectangle (viewed from above)
            const shape = new THREE.Shape();
            const x = -width / 2;
            const y = -depth / 2;
            const w = width;
            const h = depth;
            const r = radius;
            
            shape.moveTo(x + r, y);
            shape.lineTo(x + w - r, y);
            shape.quadraticCurveTo(x + w, y, x + w, y + r);
            shape.lineTo(x + w, y + h - r);
            shape.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
            shape.lineTo(x + r, y + h);
            shape.quadraticCurveTo(x, y + h, x, y + h - r);
            shape.lineTo(x, y + r);
            shape.quadraticCurveTo(x, y, x + r, y);
            
            const extrudeSettings = {
                depth: height,
                bevelEnabled: false
            };
            
            const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            geometry.rotateX(Math.PI / 2);
            geometry.translate(0, height / 2, 0);
            
            return geometry;
        }
        
        // Create a tapered geometry where edges point toward the vanishing point
        function createTaperedPersonGeometry(x, z, birthYear, deathYear, sex, height) {
            const birthPerspective = applyPerspective(x, z, birthYear);
            const topYear = deathYear || CURRENT_YEAR;
            const topPerspective = applyPerspective(x, z, topYear);
            
            // Calculate the offset from origin for bottom and top
            const bottomOffsetX = birthPerspective.x - VANISHING_POINT.x;
            const bottomOffsetZ = birthPerspective.z - VANISHING_POINT.z;
            const topOffsetX = topPerspective.x - VANISHING_POINT.x;
            const topOffsetZ = topPerspective.z - VANISHING_POINT.z;
            
            // Create custom geometry with vertices
            const geometry = new THREE.BufferGeometry();
            
            const hw = PERSON_WIDTH / 2;
            const hd = PERSON_DEPTH / 2;
            const hh = height / 2;
            
            // Calculate scale factors for top and bottom based on distance from origin
            const bottomScale = birthPerspective.scale;
            const topScale = topPerspective.scale;
            
            const vertices = new Float32Array([
                // Bottom face (smaller, closer to origin)
                -hw * bottomScale, -hh, -hd * bottomScale,
                 hw * bottomScale, -hh, -hd * bottomScale,
                 hw * bottomScale, -hh,  hd * bottomScale,
                -hw * bottomScale, -hh,  hd * bottomScale,
                
                // Top face (larger, further from origin)
                -hw * topScale, hh, -hd * topScale,
                 hw * topScale, hh, -hd * topScale,
                 hw * topScale, hh,  hd * topScale,
                -hw * topScale, hh,  hd * topScale,
            ]);
            
            const indices = new Uint16Array([
                // Bottom
                0, 2, 1, 0, 3, 2,
                // Top
                4, 5, 6, 4, 6, 7,
                // Sides
                0, 1, 5, 0, 5, 4,
                1, 2, 6, 1, 6, 5,
                2, 3, 7, 2, 7, 6,
                3, 0, 4, 3, 4, 7,
            ]);
            
            geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
            geometry.setIndex(new THREE.BufferAttribute(indices, 1));
            geometry.computeVertexNormals();
            
            return geometry;
        }

        function createPerson(data) {
            const { id, name, sex, birthYear, birthMonth = 6, deathYear, x, z, motherId } = data;
            
            // Calculate Y position and height (including months for precision)
            // Present is at TOP (high Y), past at BOTTOM (low Y) - building Mount Improbable upward
            const birthDecimal = birthYear + (birthMonth - 1) / 12;
            const conceptionDecimal = birthDecimal - (9/12); // 9 months before birth
            const currentAge = deathYear ? 
                (deathYear - birthDecimal) : 
                (CURRENT_YEAR + 11/12 - birthDecimal); // Current month assumed as Dec
            const height = currentAge * YEAR_SCALE;
            const birthHeight = (birthDecimal - OLDEST_YEAR) * YEAR_SCALE; // Birth position from bottom
            const yPosition = birthHeight + height / 2; // Center of the box (birth + half height)
            
            // Apply evolutionary perspective - positions converge toward origin of life
            const birthPerspective = applyPerspective(x, z, birthDecimal);
            const deathOrCurrentYear = deathYear || CURRENT_YEAR;
            const topPerspective = applyPerspective(x, z, deathOrCurrentYear);

            // Create tapered geometry pointing toward origin
            const geometry = createTaperedPersonGeometry(x, z, birthDecimal, deathOrCurrentYear, sex, height);
            
            // Create material based on sex and living status
            let color;
            if (deathYear) {
                // Deceased - grey color
                color = 0x888888;
            } else {
                // Living - normal colors
                color = sex === 'F' ? 0xff69b4 : 0x4169e1; // Pink for female, blue for male
            }
            
            const material = new THREE.MeshPhongMaterial({ 
                color: color,
                shininess: 30,
                transparent: true,
                opacity: deathYear ? 0.6 : 0.9  // More transparent if deceased
            });

            const mesh = new THREE.Mesh(geometry, material);
            
            // Calculate the angle to tilt the stack toward origin point (below in the past)
            // The stack should lean downward and inward so bottom points toward the vanishing point
            const bottomPos = new THREE.Vector3(birthPerspective.x, birthHeight, birthPerspective.z);
            const topPos = new THREE.Vector3(topPerspective.x, birthHeight + height, topPerspective.z);
            const centerPos = new THREE.Vector3(
                (birthPerspective.x + topPerspective.x) / 2,
                yPosition,
                (birthPerspective.z + topPerspective.z) / 2
            );
            
            // Calculate the origin point position in 3D space
            const originHeight = (ORIGIN_YEAR - OLDEST_YEAR) * YEAR_SCALE;
            const originPoint = new THREE.Vector3(VANISHING_POINT.x, originHeight, VANISHING_POINT.z);
            
            // Vector from stack bottom to origin point
            const toOrigin = new THREE.Vector3().subVectors(originPoint, bottomPos);
            const distance = toOrigin.length();
            
            // Calculate rotation to point the stack axis toward origin
            // Stack should tilt so its bottom edge points toward origin point
            const horizontalDist = Math.sqrt(
                (centerPos.x - VANISHING_POINT.x) ** 2 + 
                (centerPos.z - VANISHING_POINT.z) ** 2
            );
            const verticalDist = Math.abs(originHeight - yPosition);
            
            // Tilt angles to make stack point toward origin
            const tiltAmount = perspectiveEnabled ? Math.atan2(horizontalDist, verticalDist) : 0;
            const tiltFactor = 0.6; // Increased for more visible effect
            
            // Calculate direction-based tilts (inverted to point toward, not away)
            const xTilt = tiltAmount * tiltFactor * (centerPos.z - VANISHING_POINT.z) / (horizontalDist + 0.1);
            const zTilt = -tiltAmount * tiltFactor * (centerPos.x - VANISHING_POINT.x) / (horizontalDist + 0.1);
            
            // Apply position and rotation
            mesh.position.set(centerPos.x, centerPos.y, centerPos.z);
            mesh.rotation.x = xTilt;
            mesh.rotation.z = zTilt;
            
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            // Store perspective data for later use
            mesh.userData.birthPerspective = birthPerspective;
            mesh.userData.topPerspective = topPerspective;

            if (sex === 'F' && !deathYear) {
                // Add subtle emissive glow to living females
                material.emissive = new THREE.Color(0xff1493);
                material.emissiveIntensity = 0.1;
            }

            // Store reference to person data
            mesh.userData = data;
            mesh.userData.x = x; // Store original x for perspective calculations
            mesh.userData.z = z; // Store original z for perspective calculations
            mesh.userData.birthHeight = birthHeight;
            mesh.userData.conceptionHeight = (conceptionDecimal - OLDEST_YEAR) * YEAR_SCALE;

            personMeshes.set(id, mesh);
            scene.add(mesh);

            // Add germline substack (reproductive cells - where gametes come from)
            const germlineHeight = height * 0.9; // Germline runs most of the body height
            const germlineWidth = PERSON_WIDTH * 0.15; // Thin central line
            const germlineDepth = PERSON_DEPTH * 0.15;
            
            // Create tapered germline
            const germlineStartYear = birthDecimal + (currentAge * 0.05); // Start slightly after birth
            const germlineEndYear = deathOrCurrentYear - (currentAge * 0.05); // End slightly before top
            const germlineGeometry = createTaperedPersonGeometry(
                x, z, germlineStartYear, germlineEndYear, sex, germlineHeight
            );
            
            // Scale down the germline
            germlineGeometry.scale(0.15, 1, 0.15);
            const germlineMaterial = new THREE.MeshPhongMaterial({
                color: 0xffaa00, // Orange/gold for germline
                shininess: 30,
                transparent: true,
                opacity: 0.4, // More subtle
                emissive: new THREE.Color(0xffaa00),
                emissiveIntensity: 0.1 // Reduced glow
            });
            
            const germlineMesh = new THREE.Mesh(germlineGeometry, germlineMaterial);
            germlineMesh.position.copy(mesh.position); // Same position as main mesh
            germlineMesh.rotation.copy(mesh.rotation); // Same rotation as main mesh
            germlineMesh.userData = { isGermline: true, personId: id };
            scene.add(germlineMesh);
            
            // Store germline position for conception connections
            mesh.userData.germlinePosition = { 
                x: centerPos.x, 
                y: centerPos.y, 
                z: centerPos.z 
            };

            // Add gestation period visualization (9 months growing inside mother)
            if (motherId) {
                addGestationStack(data, mesh.userData.conceptionHeight, birthHeight, color, birthPerspective);
            }

            // Add name label at the center of the stack
            addNameLabel(name, centerPos.x, centerPos.y + height / 2 + 0.5, centerPos.z);
            
            // Add life events markers
            addLifeEventsMarkers(id, x, z, birthDecimal, deathOrCurrentYear, birthHeight, height, centerPos, mesh.rotation);
            
            // Create genome visualization (hidden by default)
            addDiploidGenomeVisualization(id, centerPos, height, sex, motherId, data.fatherId);

            return mesh;
        }
        
        function addDiploidGenomeVisualization(personId, centerPos, personHeight, sex, motherId, fatherId) {
            // Create compact genome visualization as small colored squares inside the person stack
            const genomeGroup = new THREE.Group();
            
            const numBars = 20; // Number of squares per chromosome
            const squareSize = 0.04;
            const squareGap = 0.005;
            const chromSpacing = 0.06; // Space between maternal and paternal
            
            // Four DNA base colors: Adenine (red), Thymine (green), Guanine (blue), Cytosine (yellow)
            const baseColors = [
                0xff4444, // A - Red
                0x44ff44, // T - Green  
                0x4444ff, // G - Blue
                0xffff44  // C - Yellow
            ];
            
            const baseNames = ['A', 'T', 'G', 'C'];
            
            // Generate random genome sequence (in real use, this would come from actual genetic data)
            function generateRandomGenome(length) {
                const genome = [];
                for (let i = 0; i < length; i++) {
                    genome.push(Math.floor(Math.random() * 4));
                }
                return genome;
            }
            
            const maternalGenome = generateRandomGenome(numBars);
            const paternalGenome = generateRandomGenome(numBars);
            
            // Store genome data for genome browser
            const genomeData = {
                personId: personId,
                maternal: maternalGenome,
                paternal: paternalGenome,
                baseColors: baseColors,
                baseNames: baseNames
            };
            
            // Create maternal chromosome (left column)
            for (let i = 0; i < numBars; i++) {
                const baseIndex = maternalGenome[i];
                const color = baseColors[baseIndex];
                
                const geometry = new THREE.BoxGeometry(squareSize, squareSize, squareSize);
                const material = new THREE.MeshPhongMaterial({ 
                    color: color,
                    emissive: color,
                    emissiveIntensity: 0.4
                });
                
                const square = new THREE.Mesh(geometry, material);
                square.position.set(
                    -chromSpacing / 2,
                    i * (squareSize + squareGap) - (numBars * (squareSize + squareGap)) / 2,
                    0
                );
                genomeGroup.add(square);
            }
            
            // Create paternal chromosome (right column)
            for (let i = 0; i < numBars; i++) {
                const baseIndex = paternalGenome[i];
                const color = baseColors[baseIndex];
                
                const geometry = new THREE.BoxGeometry(squareSize, squareSize, squareSize);
                const material = new THREE.MeshPhongMaterial({ 
                    color: color,
                    emissive: color,
                    emissiveIntensity: 0.4
                });
                
                const square = new THREE.Mesh(geometry, material);
                square.position.set(
                    chromSpacing / 2,
                    i * (squareSize + squareGap) - (numBars * (squareSize + squareGap)) / 2,
                    0
                );
                genomeGroup.add(square);
            }
            
            // Position the genome group inside the person stack (slightly forward)
            genomeGroup.position.set(
                centerPos.x,
                centerPos.y,
                centerPos.z + 0.35
            );
            
            genomeGroup.visible = genomesVisible;
            genomeGroup.userData = {
                isGenome: true,
                personId: personId,
                genomeData: genomeData
            };
            
            scene.add(genomeGroup);
            genomeVisualizations.push(genomeGroup);
        }
        
        function createGenomeLegend() {
            // Create a legend sprite showing genome information
            const canvas = document.createElement('canvas');
            canvas.width = 320;
            canvas.height = 140;
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = '#000000';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Diploid Genome (2n)', canvas.width/2, 25);
            
            // Color legend for DNA bases
            ctx.font = '16px Arial';
            const legendY = 50;
            const spacing = 70;
            
            // Draw legend boxes and labels
            const legendColors = [
                {color: '#ff4444', label: 'A', x: 20},
                {color: '#44ff44', label: 'T', x: 20 + spacing},
                {color: '#4444ff', label: 'G', x: 20 + spacing * 2},
                {color: '#ffff44', label: 'C', x: 20 + spacing * 3}
            ];
            
            legendColors.forEach(item => {
                ctx.fillStyle = item.color;
                ctx.fillRect(item.x, legendY, 15, 15);
                ctx.fillStyle = '#000000';
                ctx.fillText(item.label, item.x + 27, legendY + 12);
            });
            
            ctx.font = '18px Arial';
            ctx.fillStyle = '#ff1493';
            ctx.fillText('♀ Maternal', canvas.width/2 - 60, 95);
            ctx.fillStyle = '#1e90ff';
            ctx.fillText('♂ Paternal', canvas.width/2 + 60, 95);
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ 
                map: texture,
                transparent: true,
                opacity: 0.95
            });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(4, 1.75, 1);
            sprite.position.set(-8, 25, -5);
            
            sprite.visible = true; // Always visible when created
            sprite.userData = { isGenomeLegend: true };
            
            scene.add(sprite);
            genomeVisualizations.push(sprite);
        }
        
        function addLifeEventsMarkers(personId, x, z, birthDecimal, topYear, birthHeight, personHeight, centerPos, rotation) {
            // Get all life events for this person
            const personEvents = lifeEvents.filter(event => event.personId === personId);
            
            if (personEvents.length === 0) return;
            
            personEvents.forEach(event => {
                const eventYear = event.onsetYear + 0.5; // Mid-year
                
                // Skip if event is outside person's lifetime
                if (eventYear < birthDecimal || eventYear > topYear) return;
                
                // Calculate Y position of event on the person's timeline
                const eventHeight = (eventYear - OLDEST_YEAR) * YEAR_SCALE;
                
                // Apply perspective to event position
                const eventPerspective = applyPerspective(x, z, eventYear);
                
                // Determine marker color and size based on event type and severity
                let markerColor, markerSize;
                switch (event.severity) {
                    case 'severe':
                        markerColor = 0xff0000; // Red
                        markerSize = 0.4;
                        break;
                    case 'moderate':
                        markerColor = 0xff9900; // Orange
                        markerSize = 0.3;
                        break;
                    case 'mild':
                        markerColor = 0xffff00; // Yellow
                        markerSize = 0.25;
                        break;
                    case 'positive':
                        markerColor = 0x00ff00; // Green
                        markerSize = 0.3;
                        break;
                    default:
                        markerColor = 0xffffff; // White
                        markerSize = 0.25;
                }
                
                // Create marker sphere
                const markerGeometry = new THREE.SphereGeometry(markerSize, 16, 16);
                const markerMaterial = new THREE.MeshPhongMaterial({
                    color: markerColor,
                    emissive: markerColor,
                    emissiveIntensity: 0.5,
                    transparent: true,
                    opacity: 0.9
                });
                const marker = new THREE.Mesh(markerGeometry, markerMaterial);
                
                // Position marker at the side of the person stack
                const offsetDistance = 1.2;
                marker.position.set(
                    eventPerspective.x + offsetDistance,
                    eventHeight,
                    eventPerspective.z
                );
                
                // Store event data
                marker.userData = {
                    isLifeEvent: true,
                    personId: personId,
                    event: event
                };
                
                marker.visible = lifeEventsVisible;
                scene.add(marker);
                lifeEventMarkers.push(marker);
                
                // Add connecting line from marker to person stack
                const linePoints = [
                    new THREE.Vector3(centerPos.x, eventHeight, centerPos.z),
                    new THREE.Vector3(eventPerspective.x + offsetDistance, eventHeight, eventPerspective.z)
                ];
                const lineGeometry = new THREE.BufferGeometry().setFromPoints(linePoints);
                const lineMaterial = new THREE.LineBasicMaterial({
                    color: markerColor,
                    transparent: true,
                    opacity: 0.5
                });
                const line = new THREE.Line(lineGeometry, lineMaterial);
                line.visible = lifeEventsVisible;
                scene.add(line);
                lifeEventMarkers.push(line);
            });
        }

        function addGestationStack(data, conceptionHeight, birthHeight, childColor, childPerspective) {
            const { motherId, sex, birthYear, birthMonth = 6 } = data;
            
            const mother = personMeshes.get(motherId);
            if (!mother) return;
            
            const gestationHeight = birthHeight - conceptionHeight; // 9 months
            const birthDecimal = birthYear + (birthMonth - 1) / 12;
            const conceptionDecimal = birthDecimal - (9/12);
            
            // Create a tapered geometry that grows from a point to full size
            // We'll use multiple segments to create the growing effect
            const segments = 10;
            const segmentHeight = gestationHeight / segments;
            
            for (let i = 0; i < segments; i++) {
                const t = i / segments; // 0 to 1
                const nextT = (i + 1) / segments;
                
                // Calculate year for this segment (interpolate from conception to birth)
                const segmentBottomYear = conceptionDecimal + (birthDecimal - conceptionDecimal) * t;
                const segmentTopYear = conceptionDecimal + (birthDecimal - conceptionDecimal) * nextT;
                
                // Create tapered segment geometry
                const segmentGeom = createTaperedPersonGeometry(
                    mother.userData.x || mother.position.x,
                    mother.userData.z || mother.position.z,
                    segmentBottomYear,
                    segmentTopYear,
                    sex,
                    segmentHeight
                );
                
                // Scale by growth factor (grows from point to full size)
                segmentGeom.scale(nextT, 1, nextT);
                
                const segmentPerspective = applyPerspective(
                    mother.userData.x || mother.position.x, 
                    mother.userData.z || mother.position.z, 
                    segmentBottomYear
                );
                
                const segmentMaterial = new THREE.MeshPhongMaterial({
                    color: childColor,
                    transparent: true,
                    opacity: 0.5,
                    shininess: 20
                });
                
                const segment = new THREE.Mesh(segmentGeom, segmentMaterial);
                
                const segmentBottomPerspective = applyPerspective(
                    mother.userData.x || mother.position.x, 
                    mother.userData.z || mother.position.z, 
                    segmentBottomYear
                );
                const segmentTopPerspective = applyPerspective(
                    mother.userData.x || mother.position.x, 
                    mother.userData.z || mother.position.z, 
                    segmentTopYear
                );
                
                const segmentCenterY = conceptionHeight + i * segmentHeight + segmentHeight / 2;
                const segmentCenterPos = new THREE.Vector3(
                    (segmentBottomPerspective.x + segmentTopPerspective.x) / 2,
                    segmentCenterY,
                    (segmentBottomPerspective.z + segmentTopPerspective.z) / 2
                );
                
                // Calculate tilt toward origin (same as person stacks)
                const originHeight = (ORIGIN_YEAR - OLDEST_YEAR) * YEAR_SCALE;
                const horizontalDist = Math.sqrt(
                    (segmentCenterPos.x - VANISHING_POINT.x) ** 2 + 
                    (segmentCenterPos.z - VANISHING_POINT.z) ** 2
                );
                const verticalDist = Math.abs(originHeight - segmentCenterY);
                const tiltAmount = perspectiveEnabled ? Math.atan2(horizontalDist, verticalDist) : 0;
                const tiltFactor = 0.6;
                
                const xTilt = tiltAmount * tiltFactor * (segmentCenterPos.z - VANISHING_POINT.z) / (horizontalDist + 0.1);
                const zTilt = -tiltAmount * tiltFactor * (segmentCenterPos.x - VANISHING_POINT.x) / (horizontalDist + 0.1);
                
                segment.position.copy(segmentCenterPos);
                segment.rotation.x = xTilt;
                segment.rotation.z = zTilt;
                
                // Store detailed gestation info for click interaction
                const weekStart = Math.floor((i / segments) * 40);
                const weekEnd = Math.floor((nextT) * 40);
                const trimester = weekStart < 13 ? 1 : weekStart < 27 ? 2 : 3;
                
                segment.userData = { 
                    isGestation: true, 
                    childId: data.id,
                    motherId: motherId,
                    childName: data.name,
                    motherName: mother.userData.name,
                    weekStart: weekStart,
                    weekEnd: weekEnd,
                    trimester: trimester,
                    gestationSegment: i
                };
                conceptionLines.push(segment);
                scene.add(segment);
            }
            
            // Add birth transition line from mother position to child's birth position
            const childData = personMeshes.get(data.id);
            const childBirthPos = applyPerspective(data.x, data.z, birthDecimal);
            const motherBirthPos = applyPerspective(
                mother.userData.x || mother.position.x,
                mother.userData.z || mother.position.z,
                birthDecimal
            );
            
            const birthTransitionPoints = [
                new THREE.Vector3(motherBirthPos.x, birthHeight, motherBirthPos.z),
                new THREE.Vector3(childBirthPos.x, birthHeight, childBirthPos.z)
            ];
            
            const birthLineGeometry = new THREE.BufferGeometry().setFromPoints(birthTransitionPoints);
            const birthLineMaterial = new THREE.LineBasicMaterial({
                color: 0x00ffaa,
                transparent: true,
                opacity: 0.6,
                linewidth: 2
            });
            
            const birthLine = new THREE.Line(birthLineGeometry, birthLineMaterial);
            birthLine.userData = { isBirthTransition: true, childId: data.id };
            conceptionLines.push(birthLine);
            scene.add(birthLine);
            
            // Add arrow showing child "coming out" from mother to independent position
            addArrow(
                new THREE.Vector3(motherBirthPos.x, birthHeight, motherBirthPos.z),
                new THREE.Vector3(childBirthPos.x, birthHeight, childBirthPos.z),
                0x00ffaa
            );
            
            // Add "birth event" marker at mother's position
            const birthMarkerGeometry = new THREE.SphereGeometry(0.15, 16, 16);
            const birthMarkerMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ffaa,
                transparent: true,
                opacity: 0.8
            });
            
            const birthMarker = new THREE.Mesh(birthMarkerGeometry, birthMarkerMaterial);
            birthMarker.position.set(motherBirthPos.x, birthHeight, motherBirthPos.z);
            birthMarker.userData = { isBirthMarker: true, childId: data.id };
            conceptionLines.push(birthMarker);
            scene.add(birthMarker);
        }

        function addNameLabel(text, x, y, z) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 64;
            context.fillStyle = '#ffffff';
            context.font = 'Bold 32px Arial';
            context.textAlign = 'center';
            context.fillText(text, 128, 40);

            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.set(x, y, z);
            sprite.scale.set(1.5, 0.375, 1);
            scene.add(sprite);
        }

        function createConceptionBar(fatherId, motherId, childId) {
            const father = personMeshes.get(fatherId);
            const mother = personMeshes.get(motherId);
            const child = personMeshes.get(childId);

            if (!father || !mother || !child) {
                console.error('Missing person for conception bar');
                return;
            }

            // Use CONCEPTION height (9 months before birth) not birth height
            const conceptionHeight = child.userData.conceptionHeight;
            const childBirthYear = child.userData.birthYear;
            const conceptionYear = childBirthYear - 0.75; // 9 months before birth
            
            // Get perspective positions at conception time
            const fatherConceptionPos = applyPerspective(
                father.userData.x || father.position.x,
                father.userData.z || father.position.z,
                conceptionYear
            );
            const motherConceptionPos = applyPerspective(
                mother.userData.x || mother.position.x,
                mother.userData.z || mother.position.z,
                conceptionYear
            );

            // Create points for the connection at conception time (when sperm fertilizes egg)
            const points = [];
            
            // Father's GERMLINE position at conception time (sperm comes from germline)
            points.push(new THREE.Vector3(fatherConceptionPos.x, conceptionHeight, fatherConceptionPos.z));

            // Mother's GERMLINE position at conception time (egg comes from germline, fertilized egg starts here)
            points.push(new THREE.Vector3(motherConceptionPos.x, conceptionHeight, motherConceptionPos.z));

            // NOTE: We don't connect to child's position here because at conception,
            // the child is just a point inside the mother

            // Create the line geometry (just father to mother at conception)
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({ 
                color: 0xffff00,
                linewidth: 3,
                transparent: true,
                opacity: 0.8
            });

            const line = new THREE.Line(geometry, material);
            scene.add(line);
            
            // Store line with family info
            line.userData = { fatherId, motherId, childId };
            conceptionLines.push(line);

            // Add arrow pointing from father to mother at conception to show direction of inheritance
            addArrow(new THREE.Vector3(fatherConceptionPos.x, conceptionHeight, fatherConceptionPos.z), 
                     new THREE.Vector3(motherConceptionPos.x, conceptionHeight, motherConceptionPos.z), 0xffff00);

            // Add small spheres at connection points
            const sphereGeometry = new THREE.SphereGeometry(0.1, 16, 16);
            const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            
            points.forEach(point => {
                const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                sphere.position.copy(point);
                sphere.userData = { fatherId, motherId, childId };
                conceptionLines.push(sphere);
                scene.add(sphere);
            });
        }

        function addArrow(from, to, color) {
            // Calculate direction and distance
            const direction = new THREE.Vector3().subVectors(to, from);
            const distance = direction.length();
            direction.normalize();
            
            // Position arrow 70% of the way from parent to child
            const arrowPosition = from.clone().add(direction.clone().multiplyScalar(distance * 0.7));
            
            // Create arrow using cone geometry
            const arrowLength = 0.3;
            const arrowRadius = 0.15;
            const arrowGeometry = new THREE.ConeGeometry(arrowRadius, arrowLength, 8);
            const arrowMaterial = new THREE.MeshBasicMaterial({ 
                color: color,
                transparent: true,
                opacity: 0.8
            });
            const arrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
            
            // Position and orient the arrow
            arrow.position.copy(arrowPosition);
            
            // Point the arrow in the direction from parent to child
            const axis = new THREE.Vector3(0, 1, 0);
            const quaternion = new THREE.Quaternion();
            quaternion.setFromUnitVectors(axis, direction);
            arrow.quaternion.copy(quaternion);
            
            // Store for opacity control
            arrow.userData = { isArrow: true };
            conceptionLines.push(arrow);
            
            scene.add(arrow);
        }

        // Data loaded from API
        let familyData = [];
        let conceptions = [];
        let families = [];
        let lifeEvents = [];

        // API configuration
        const API_BASE_URL = 'http://localhost:3001/api';

        // Load data from MongoDB API
        async function loadDataFromAPI() {
            try {
                document.getElementById('loading').innerHTML = 'Loading family data...';
                
                // Fetch all data in parallel
                const [personsResponse, conceptionsResponse, familiesResponse, lifeEventsResponse] = await Promise.all([
                    fetch(`${API_BASE_URL}/persons`),
                    fetch(`${API_BASE_URL}/conceptions`),
                    fetch(`${API_BASE_URL}/families`),
                    fetch(`${API_BASE_URL}/lifeEvents`)
                ]);

                if (!personsResponse.ok || !conceptionsResponse.ok || !familiesResponse.ok || !lifeEventsResponse.ok) {
                    throw new Error('Failed to fetch data from API');
                }

                const persons = await personsResponse.json();
                const conceptionsData = await conceptionsResponse.json();
                families = await familiesResponse.json();
                lifeEvents = await lifeEventsResponse.json();

                // Transform MongoDB data to visualization format
                familyData = persons.map(person => ({
                    id: person.id,
                    name: person.name,
                    sex: person.sex === 'male' ? 'M' : 'F',
                    birthYear: person.birthYear,
                    birthMonth: person.birthMonth,
                    deathYear: person.deathYear,
                    motherId: person.motherId,
                    fatherId: person.fatherId,
                    x: person.x || 0,
                    z: person.z || 0
                }));

                // Transform conceptions data
                conceptions = conceptionsData.map(c => ({
                    father: c.fatherId,
                    mother: c.motherId,
                    child: c.childId
                }));

                console.log(`Loaded ${familyData.length} persons, ${conceptions.length} conceptions, ${families.length} families, ${lifeEvents.length} life events from API`);
                return true;
            } catch (error) {
                console.error('Error loading data from API:', error);
                document.getElementById('loading').innerHTML = 
                    'Error loading data from API. Make sure the server is running on port 3001.<br><br>' + 
                    error.message + '<br><br>Run: npm start';
                document.getElementById('loading').style.background = 'rgba(255, 100, 0, 0.8)';
                return false;
            }
        }

        function createFamily() {
            // Populate familyMembers from loaded families data
            families.forEach(family => {
                familyMembers[family.id] = family.members;
            });
            
            // Add evolutionary perspective guide only when perspective is enabled
            if (perspectiveEnabled) {
                addEvolutionaryPerspectiveGuide();
            }

            // Create all people
            familyData.forEach(person => createPerson(person));

            // Create conception bars
            conceptions.forEach(conception => {
                createConceptionBar(conception.father, conception.mother, conception.child);
            });
        }
        
        // Add visual guide showing convergence toward origin point
        function addEvolutionaryPerspectiveGuide() {
            const originHeight = (ORIGIN_YEAR - OLDEST_YEAR) * YEAR_SCALE;
            const presentHeight = (CURRENT_YEAR - OLDEST_YEAR) * YEAR_SCALE;
            
            // ELEVATION CONTOURS - Rings showing climbing progress up the mountain
            const totalHeight = presentHeight - originHeight;
            const numContours = 8;
            
            for (let i = 1; i <= numContours; i++) {
                const progress = i / numContours;
                const contourHeight = originHeight + (totalHeight * progress);
                const contourYear = ORIGIN_YEAR + ((CURRENT_YEAR - ORIGIN_YEAR) * progress);
                
                // Rings get smaller as we climb (mountain gets narrower)
                const baseRadius = 15 * (1 - progress * 0.6);
                
                // Create contour as a line that follows perspective
                const segments = 64;
                const contourPoints = [];
                
                for (let j = 0; j <= segments; j++) {
                    const angle = (j / segments) * Math.PI * 2;
                    const x = Math.cos(angle) * baseRadius;
                    const z = Math.sin(angle) * baseRadius;
                    
                    // Apply perspective transformation to each point
                    const perspectivePos = applyPerspective(x, z, contourYear);
                    contourPoints.push(new THREE.Vector3(perspectivePos.x, contourHeight, perspectivePos.z));
                }
                
                const contourGeometry = new THREE.BufferGeometry().setFromPoints(contourPoints);
                const contourMaterial = new THREE.LineBasicMaterial({
                    color: 0x6a8a9a,
                    transparent: true,
                    opacity: 0.3 + (progress * 0.2)
                });
                const contourLine = new THREE.Line(contourGeometry, contourMaterial);
                scene.add(contourLine);
                
                // Add elevation markers
                if (i % 2 === 0) {
                    const markerAngle = Math.PI / 4;
                    const markerX = Math.cos(markerAngle) * baseRadius;
                    const markerZ = Math.sin(markerAngle) * baseRadius;
                    const markerPos = applyPerspective(markerX, markerZ, contourYear);
                    
                    const markerCanvas = document.createElement('canvas');
                    markerCanvas.width = 256;
                    markerCanvas.height = 64;
                    const ctx = markerCanvas.getContext('2d');
                    ctx.fillStyle = '#8aaaaa';
                    ctx.font = 'bold 24px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(`Elevation: ${Math.round(progress * 100)}%`, 128, 40);
                    
                    const markerTexture = new THREE.CanvasTexture(markerCanvas);
                    const markerMaterial = new THREE.SpriteMaterial({ 
                        map: markerTexture,
                        transparent: true,
                        opacity: 0.6
                    });
                    const marker = new THREE.Sprite(markerMaterial);
                    marker.position.set(markerPos.x, contourHeight, markerPos.z);
                    marker.scale.set(3, 0.75, 1);
                    scene.add(marker);
                }
            }
            
            // Original perspective guide elements (converging lines)
            const guidePositions = [
                { x: -10, z: -10 },
                { x: -10, z: 10 },
                { x: 10, z: -10 },
                { x: 10, z: 10 },
                { x: 0, z: -15 },
                { x: 0, z: 15 },
                { x: -15, z: 0 },
                { x: 15, z: 0 }
            ];
            
            const lineColor = 0x3a5a7a;
            const lineMaterial = new THREE.LineBasicMaterial({ 
                color: lineColor,
                transparent: true,
                opacity: 0.15
            });
            
            guidePositions.forEach(pos => {
                // Line from present position down to origin point
                const presentPos = applyPerspective(pos.x, pos.z, CURRENT_YEAR);
                const originPos = applyPerspective(pos.x, pos.z, ORIGIN_YEAR);
                
                const points = [
                    new THREE.Vector3(presentPos.x, presentHeight, presentPos.z),
                    new THREE.Vector3(originPos.x, originHeight, originPos.z)
                ];
                
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const line = new THREE.Line(geometry, lineMaterial);
                scene.add(line);
            });
            
            // Add a prominent marker at the origin point (small because it's far away)
            const originGeometry = new THREE.SphereGeometry(0.3, 32, 32);
            const originMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xffaa00,
                emissive: 0xffaa00,
                emissiveIntensity: 1.2,
                transparent: true,
                opacity: 1.0
            });
            const originMarker = new THREE.Mesh(originGeometry, originMaterial);
            originMarker.position.set(VANISHING_POINT.x, originHeight, VANISHING_POINT.z);
            scene.add(originMarker);
            
            // Add pulsing point light at origin (small but intense)
            const originLight = new THREE.PointLight(0xffaa00, 3, 8);
            originLight.position.set(VANISHING_POINT.x, originHeight, VANISHING_POINT.z);
            scene.add(originLight);
            
            // Animate the light to pulse (more dramatic for distant point)
            const originLightData = { light: originLight, phase: 0 };
            function animateOriginLight() {
                originLightData.phase += 0.08;
                originLightData.light.intensity = 2 + Math.sin(originLightData.phase) * 1.5;
                requestAnimationFrame(animateOriginLight);
            }
            animateOriginLight();
            
            // Add a subtle grid at the origin level
            const gridSize = 30;
            const gridDivisions = 15;
            const gridHelper = new THREE.GridHelper(gridSize, gridDivisions, 0x4a6a8a, 0x3a5a7a);
            gridHelper.position.y = originHeight - 0.1;
            gridHelper.material.transparent = true;
            gridHelper.material.opacity = 0.1;
            scene.add(gridHelper);
            
            // Add clear text label for origin point
            const originLabelGeometry = new THREE.PlaneGeometry(8, 1.2);
            const canvas = document.createElement('canvas');
            canvas.width = 1024;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            
            // Add glow effect
            ctx.shadowColor = '#ffaa00';
            ctx.shadowBlur = 20;
            ctx.fillStyle = '#ffdd66';
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('⚡ ORIGIN OF LIFE ⚡', 512, 70);
            
            // Add year subtitle
            ctx.shadowBlur = 10;
            ctx.font = '32px Arial';
            ctx.fillStyle = '#ffbb44';
            ctx.fillText(`(${ORIGIN_YEAR})`, 512, 105);
            
            const texture = new THREE.CanvasTexture(canvas);
            const labelMaterial = new THREE.MeshBasicMaterial({ 
                map: texture, 
                transparent: true,
                opacity: 0.9,
                side: THREE.DoubleSide
            });
            const label = new THREE.Mesh(originLabelGeometry, labelMaterial);
            label.position.set(0, originHeight - 1.5, 0);
            label.rotation.x = -Math.PI / 2;
            scene.add(label);
        }

        function onMouseClick(event) {
            const container = document.getElementById('canvas-container');
            const rect = container.getBoundingClientRect();
            
            const mouse = new THREE.Vector2();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);

            // Check for genome visualizations first
            const allObjects = scene.children;
            const genomeIntersects = raycaster.intersectObjects(
                allObjects.filter(obj => obj.userData.isGenome),
                true // Check children
            );
            
            if (genomeIntersects.length > 0) {
                const genomeGroup = genomeIntersects[0].object.parent;
                if (genomeGroup && genomeGroup.userData.genomeData) {
                    openGenomeBrowser(genomeGroup.userData.genomeData);
                    return;
                }
            }

            // Check for life event markers
            const lifeEventIntersects = raycaster.intersectObjects(allObjects.filter(obj => obj.userData.isLifeEvent));
            
            if (lifeEventIntersects.length > 0) {
                const eventMarker = lifeEventIntersects[0].object;
                const eventData = eventMarker.userData.event;
                
                alert(`Life Event: ${eventData.name}\\nYear: ${eventData.onsetYear}\\nSeverity: ${eventData.severity}\\nDescription: ${eventData.description}`);
                return;
            }
            
            // Check for gestation segments
            const gestationIntersects = raycaster.intersectObjects(allObjects.filter(obj => obj.userData.isGestation));
            
            if (gestationIntersects.length > 0) {
                const gestationSegment = gestationIntersects[0].object;
                const data = gestationSegment.userData;
                
                console.log('Clicked gestation segment:', data);
                
                // Open birth view in new window
                const childMesh = personMeshes.get(data.childId);
                const motherMesh = personMeshes.get(data.motherId);
                
                if (childMesh && motherMesh) {
                    const childData = childMesh.userData;
                    const params = new URLSearchParams({
                        childId: data.childId,
                        childName: data.childName,
                        motherName: data.motherName,
                        birthYear: childData.birthYear,
                        birthMonth: childData.birthMonth || 6,
                        sex: childData.sex,
                        conceptionYear: childData.conceptionHeight / YEAR_SCALE
                    });
                    
                    const url = `birth_view.html?${params.toString()}`;
                    console.log('Opening:', url);
                    
                    // Try to open in new tab - user may need to allow popups
                    const newWindow = window.open(url, '_blank');
                    
                    if (!newWindow) {
                        // Popup blocked - show message
                        alert('Please allow popups for this site to view the birth journey.\n\nOr right-click on a gestation segment and select "Open in new tab".');
                    }
                } else {
                    console.error('Could not find child or mother mesh:', data.childId, data.motherId);
                }
                
                return;
            }
            
            // Then check for person meshes
            const meshes = Array.from(personMeshes.values());
            const intersects = raycaster.intersectObjects(meshes);

            if (intersects.length > 0) {
                const clickedMesh = intersects[0].object;
                selectPerson(clickedMesh);
            } else {
                deselectPerson();
            }
        }

        function selectPerson(mesh) {
            // Deselect previous
            if (selectedPerson) {
                selectedPerson.material.emissive.setHex(
                    selectedPerson.userData.sex === 'F' ? 0xff1493 : 0x000000
                );
                selectedPerson.material.emissiveIntensity = selectedPerson.userData.sex === 'F' ? 0.1 : 0;
            }

            // Select new
            selectedPerson = mesh;
            mesh.material.emissive.setHex(0xffff00);
            mesh.material.emissiveIntensity = 0.3;

            // Display info
            displayPersonInfo(mesh.userData);
        }

        function deselectPerson() {
            if (selectedPerson) {
                selectedPerson.material.emissive.setHex(
                    selectedPerson.userData.sex === 'F' ? 0xff1493 : 0x000000
                );
                selectedPerson.material.emissiveIntensity = selectedPerson.userData.sex === 'F' ? 0.1 : 0;
                selectedPerson = null;
            }
            document.getElementById('person-details').innerHTML = '';
        }
        
        function selectFamily(family) {
            selectedFamily = family;
            
            // Update all person meshes
            personMeshes.forEach((mesh, id) => {
                const isSmith = familyMembers.smith.includes(id);
                const isChen = familyMembers.chen.includes(id);
                const isDeceased = mesh.userData.deathYear !== null && mesh.userData.deathYear !== undefined;
                
                if (family === null) {
                    // Show all - restore colors based on living status
                    if (isDeceased) {
                        mesh.material.color.setHex(0x888888);
                        mesh.material.opacity = 0.6;
                    } else {
                        mesh.material.color.setHex(mesh.userData.sex === 'F' ? 0xff69b4 : 0x4169e1);
                        mesh.material.opacity = 0.9;
                    }
                } else if ((family === 'smith' && isSmith) || (family === 'chen' && isChen)) {
                    // Selected family - show colors based on living status
                    if (isDeceased) {
                        mesh.material.color.setHex(0x888888);
                        mesh.material.opacity = 0.6;
                    } else {
                        mesh.material.color.setHex(mesh.userData.sex === 'F' ? 0xff69b4 : 0x4169e1);
                        mesh.material.opacity = 0.9;
                    }
                } else {
                    // Non-selected family - grey and transparent
                    mesh.material.opacity = 0.3;
                    mesh.material.color.setHex(0x666666);
                }
            });
            
            // Update conception lines
            conceptionLines.forEach(obj => {
                const childId = obj.userData.childId;
                const isSmith = familyMembers.smith.includes(childId);
                const isChen = familyMembers.chen.includes(childId);
                
                if (family === null) {
                    obj.material.opacity = 0.8;
                } else if ((family === 'smith' && isSmith) || (family === 'chen' && isChen)) {
                    obj.material.opacity = 0.8;
                } else {
                    obj.material.opacity = 0.2;
                }
            });
            
            // Display family info
            displayFamilyInfo(family);
        }
        
        function displayFamilyInfo(family) {
            const infoDiv = document.getElementById('family-info');
            
            if (family === null) {
                infoDiv.innerHTML = '';
                return;
            }
            
            const familyData = {
                smith: {
                    name: 'Smith Family',
                    members: 9,
                    generations: 3,
                    oldest: 'Robert (1938)',
                    youngest: 'Sarah (1999)',
                    living: 6
                },
                chen: {
                    name: 'Chen Family',
                    members: 8,
                    generations: 3,
                    oldest: 'Tao (1943)',
                    youngest: 'Maya (2003)',
                    living: 6
                }
            };
            
            const info = familyData[family];
            const html = `
                <div class="person-info" style="background: #e3f2fd;">
                    <h3>${info.name}</h3>
                    <p><strong>Total Members:</strong> ${info.members}</p>
                    <p><strong>Generations:</strong> ${info.generations}</p>
                    <p><strong>Oldest:</strong> ${info.oldest}</p>
                    <p><strong>Youngest:</strong> ${info.youngest}</p>
                    <p><strong>Living:</strong> ${info.living}</p>
                </div>
            `;
            
            infoDiv.innerHTML = html;
        }

        function displayPersonInfo(data) {
            const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            const birthDecimal = data.birthYear + ((data.birthMonth || 6) - 1) / 12;
            const age = data.deathYear ? 
                (data.deathYear - birthDecimal) : 
                (CURRENT_YEAR + 11/12 - birthDecimal);
            
            const status = data.deathYear ? `Deceased (${data.deathYear})` : 'Living';
            const birthDate = data.birthMonth ? 
                `${monthNames[data.birthMonth - 1]} ${data.birthYear}` : 
                data.birthYear;
            
            // Get life events for this person
            const personEvents = lifeEvents.filter(event => event.personId === data.id);
            let eventsHtml = '';
            if (personEvents.length > 0) {
                eventsHtml = '<p><strong>Life Events:</strong></p><ul style="margin: 5px 0; padding-left: 20px;">';
                personEvents.forEach(event => {
                    const severityColor = {
                        'severe': '#ff0000',
                        'moderate': '#ff9900',
                        'mild': '#ffff00',
                        'positive': '#00ff00'
                    }[event.severity] || '#ffffff';
                    eventsHtml += `<li style="color: ${severityColor}; margin: 3px 0;">
                        <strong>${event.name}</strong> (${event.onsetYear})<br/>
                        <span style="color: #666; font-size: 11px;">${event.description}</span>
                    </li>`;
                });
                eventsHtml += '</ul>';
            }
            
            const html = `
                <div class="person-info">
                    <h3>${data.name}</h3>
                    <p><strong>Sex:</strong> ${data.sex === 'M' ? 'Male' : 'Female'}</p>
                    <p><strong>Birth:</strong> ${birthDate}</p>
                    <p><strong>Age:</strong> ${age.toFixed(1)} years</p>
                    <p><strong>Status:</strong> ${status}</p>
                    <p><strong>Position:</strong> (${data.x.toFixed(1)}, ${data.z.toFixed(1)})</p>
                    ${eventsHtml}
                </div>
            `;
            
            document.getElementById('person-details').innerHTML = html;
        }
        
        function displayGestationInfo(gestationData) {
            const { childName, motherName, weekStart, weekEnd, trimester, gestationSegment } = gestationData;
            
            const trimesterInfo = {
                1: { name: 'First Trimester', desc: 'Embryonic development, organ formation', weeks: '0-13' },
                2: { name: 'Second Trimester', desc: 'Rapid growth, movement begins', weeks: '14-26' },
                3: { name: 'Third Trimester', desc: 'Final development, preparing for birth', weeks: '27-40' }
            };
            
            const info = trimesterInfo[trimester];
            
            const html = `
                <div class="person-info" style="background: #e8f5e9;">
                    <h3>Gestation Period</h3>
                    <p><strong>Child:</strong> ${childName}</p>
                    <p><strong>Mother:</strong> ${motherName}</p>
                    <p><strong>Weeks:</strong> ${weekStart}-${weekEnd} of 40</p>
                    <p><strong>${info.name}</strong></p>
                    <p><em>${info.desc}</em></p>
                    <p style="font-size: 11px; color: #666; margin-top: 8px;">
                        ${info.weeks} weeks total
                    </p>
                </div>
            `;
            
            document.getElementById('person-details').innerHTML = html;
            
            // Create focused birth visualization
            createBirthFocusView(gestationData);
        }
        
        function createBirthFocusView(gestationData) {
            // Clear any existing focus view
            scene.children.filter(obj => obj.userData.isFocusView).forEach(obj => scene.remove(obj));
            
            const { childId, motherId, childName, motherName } = gestationData;
            
            // Get child and mother data
            const childMesh = personMeshes.get(childId);
            const motherMesh = personMeshes.get(motherId);
            
            if (!childMesh || !motherMesh) return;
            
            const childData = childMesh.userData;
            const motherData = motherMesh.userData;
            
            // Calculate timeline positions for focused view
            const conceptionHeight = childData.conceptionHeight;
            const birthHeight = childData.birthHeight;
            const gestationDuration = birthHeight - conceptionHeight; // 9 months
            const postBirthDuration = gestationDuration * 0.5; // Show 4.5 months after birth
            
            // Position focused view to the right of main scene
            const focusX = 20;
            const focusZ = 0;
            const timelineStart = conceptionHeight;
            
            // Create mother's stack (partial, just during gestation)
            const motherStackHeight = gestationDuration * 1.2; // Extend a bit beyond gestation
            const motherStackGeometry = new THREE.BoxGeometry(
                PERSON_WIDTH * 1.5,
                motherStackHeight,
                PERSON_DEPTH * 1.5
            );
            const motherStackMaterial = new THREE.MeshPhongMaterial({
                color: 0xff69b4,
                transparent: true,
                opacity: 0.3,
                wireframe: false
            });
            const motherStack = new THREE.Mesh(motherStackGeometry, motherStackMaterial);
            motherStack.position.set(focusX, conceptionHeight + motherStackHeight / 2, focusZ);
            motherStack.userData.isFocusView = true;
            scene.add(motherStack);
            
            // Create growing child inside mother (tapered from point to full size)
            const segments = 10;
            const segmentHeight = gestationDuration / segments;
            const childColor = childData.sex === 'F' ? 0xff69b4 : 0x4169e1;
            
            for (let i = 0; i < segments; i++) {
                const t = i / segments;
                const nextT = (i + 1) / segments;
                
                const widthTop = PERSON_WIDTH * nextT;
                const depthTop = PERSON_DEPTH * nextT;
                
                const shape = new THREE.Shape();
                const hw = widthTop / 2;
                const hd = depthTop / 2;
                
                // Rectangle for simplicity in focus view
                shape.moveTo(-hw, -hd);
                shape.lineTo(hw, -hd);
                shape.lineTo(hw, hd);
                shape.lineTo(-hw, hd);
                
                const extrudeSettings = {
                    depth: segmentHeight,
                    bevelEnabled: false,
                    steps: 1
                };
                
                const segmentGeometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
                segmentGeometry.rotateX(Math.PI / 2);
                
                const segmentMaterial = new THREE.MeshPhongMaterial({
                    color: childColor,
                    transparent: true,
                    opacity: 0.7,
                    shininess: 30
                });
                
                const segment = new THREE.Mesh(segmentGeometry, segmentMaterial);
                segment.position.set(
                    focusX,
                    conceptionHeight + i * segmentHeight + segmentHeight / 2,
                    focusZ
                );
                segment.userData.isFocusView = true;
                scene.add(segment);
            }
            
            // Add birth transition marker
            const birthMarkerGeometry = new THREE.SphereGeometry(0.3, 16, 16);
            const birthMarkerMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ffaa,
                emissive: 0x00ffaa,
                emissiveIntensity: 0.5
            });
            const birthMarker = new THREE.Mesh(birthMarkerGeometry, birthMarkerMaterial);
            birthMarker.position.set(focusX, birthHeight, focusZ);
            birthMarker.userData.isFocusView = true;
            scene.add(birthMarker);
            
            // Create child's independent stack (post-birth)
            const postBirthStackGeometry = new THREE.BoxGeometry(
                PERSON_WIDTH,
                postBirthDuration,
                PERSON_DEPTH
            );
            const postBirthStackMaterial = new THREE.MeshPhongMaterial({
                color: childColor,
                transparent: true,
                opacity: 0.8,
                shininess: 30
            });
            const postBirthStack = new THREE.Mesh(postBirthStackGeometry, postBirthStackMaterial);
            postBirthStack.position.set(
                focusX + 2, // Offset to the right to show separation
                birthHeight + postBirthDuration / 2,
                focusZ
            );
            postBirthStack.userData.isFocusView = true;
            scene.add(postBirthStack);
            
            // Add arrow showing birth transition
            const birthArrowPoints = [
                new THREE.Vector3(focusX, birthHeight, focusZ),
                new THREE.Vector3(focusX + 2, birthHeight, focusZ)
            ];
            const birthArrowGeometry = new THREE.BufferGeometry().setFromPoints(birthArrowPoints);
            const birthArrowMaterial = new THREE.LineBasicMaterial({
                color: 0x00ffaa,
                linewidth: 3
            });
            const birthArrow = new THREE.Line(birthArrowGeometry, birthArrowMaterial);
            birthArrow.userData.isFocusView = true;
            scene.add(birthArrow);
            
            // Add text labels
            addFocusLabel('CONCEPTION', focusX, conceptionHeight - 0.5, focusZ);
            addFocusLabel('BIRTH', focusX + 1, birthHeight + 0.5, focusZ);
            addFocusLabel(`${childName}'s Journey`, focusX, birthHeight + postBirthDuration + 1, focusZ);
            
            // Zoom camera to focus view
            camera.position.set(focusX + 8, birthHeight, focusZ + 8);
            controls.target.set(focusX, birthHeight, focusZ);
            controls.update();
        }
        
        function addFocusLabel(text, x, y, z) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 64;
            context.fillStyle = '#ffffff';
            context.font = 'Bold 32px Arial';
            context.textAlign = 'center';
            context.fillText(text, 128, 40);
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.set(x, y, z);
            sprite.scale.set(2, 0.5, 1);
            sprite.userData.isFocusView = true;
            scene.add(sprite);
        }

        function resetCamera() {
            camera.position.set(15, 10, 15);
            camera.lookAt(0, 0, 0);
            controls.target.set(0, 0, 0);
            controls.update();
        }
        
        function togglePerspective() {
            // Toggle the perspective state
            perspectiveEnabled = !perspectiveEnabled;
            
            // Update button text
            const button = document.getElementById('toggle-perspective');
            button.textContent = perspectiveEnabled ? 'Disable Perspective' : 'Enable Perspective';
            button.style.background = perspectiveEnabled ? '#ff6b35' : '#4CAF50';
            
            // Clear the scene (keep camera, lights, and controls)
            while(scene.children.length > 0) { 
                scene.remove(scene.children[0]); 
            }
            
            // Re-add lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // Re-add scene elements
            addPresentGrid();
            const axesHelper = new THREE.AxesHelper(5);
            if (perspectiveEnabled) {
                const originHeight = (ORIGIN_YEAR - OLDEST_YEAR) * YEAR_SCALE;
                axesHelper.position.set(VANISHING_POINT.x, originHeight, VANISHING_POINT.z);
            }
            scene.add(axesHelper);
            addAxisLabels();
            addTimeAxis();
            
            // Clear stored data
            personMeshes.clear();
            conceptionLines.length = 0;
            lifeEventMarkers.length = 0;
            genomeVisualizations.length = 0;
            
            // Recreate everything
            createFamily();
            
            // Add genome legend if genomes are visible
            if (genomesVisible) {
                createGenomeLegend();
            }
        }
        
        // Open genome browser in new window
        function openGenomeBrowser(genomeData) {
            const dataParam = encodeURIComponent(JSON.stringify(genomeData));
            const url = `genome_browser.html?data=${dataParam}`;
            window.open(url, '_blank', 'width=1400,height=900');
        }
        
        function toggleLifeEvents() {
            lifeEventsVisible = !lifeEventsVisible;
            
            // Update button text
            const button = document.getElementById('toggle-life-events');
            button.textContent = lifeEventsVisible ? 'Hide Life Events' : 'Show Life Events';
            button.style.background = lifeEventsVisible ? '#9c27b0' : '#4CAF50';
            
            // Toggle visibility of all life event markers
            lifeEventMarkers.forEach(marker => {
                marker.visible = lifeEventsVisible;
            });
        }
        
        function toggleGenomes() {
            genomesVisible = !genomesVisible;
            
            // Update button text
            const button = document.getElementById('toggle-genomes');
            button.textContent = genomesVisible ? 'Hide Diploid Genomes' : 'Show Diploid Genomes';
            button.style.background = genomesVisible ? '#2196f3' : '#4CAF50';
            
            // Toggle visibility of all genome visualizations
            genomeVisualizations.forEach(genome => {
                genome.visible = genomesVisible;
            });
            
            // Add or remove legend
            if (genomesVisible) {
                createGenomeLegend();
            }
        }
        
        let tooltip = null;
        function onMouseMove(event) {
            const container = document.getElementById('canvas-container');
            const rect = container.getBoundingClientRect();
            
            const mouse = new THREE.Vector2();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);

            // Check for life event markers
            const visibleMarkers = lifeEventMarkers.filter(m => m.visible && m.userData.isLifeEvent);
            const intersects = raycaster.intersectObjects(visibleMarkers);

            if (intersects.length > 0 && intersects[0].object.userData.isLifeEvent) {
                const eventData = intersects[0].object.userData.event;
                
                // Create or update tooltip
                if (!tooltip) {
                    tooltip = document.createElement('div');
                    tooltip.className = 'event-tooltip';
                    document.body.appendChild(tooltip);
                }
                
                const severityColors = {
                    'severe': '#ff0000',
                    'moderate': '#ff9900',
                    'mild': '#ffff00',
                    'positive': '#00ff00'
                };
                
                tooltip.innerHTML = `
                    <h4 style="color: ${severityColors[eventData.severity] || '#ffffff'}">${eventData.name}</h4>
                    <p><strong>Year:</strong> ${eventData.onsetYear}</p>
                    <p><strong>Severity:</strong> ${eventData.severity}</p>
                    <p><strong>Type:</strong> ${eventData.eventType}</p>
                    <p style="margin-top: 5px; font-style: italic;">${eventData.description}</p>
                `;
                
                tooltip.style.left = (event.clientX + 15) + 'px';
                tooltip.style.top = (event.clientY + 15) + 'px';
                tooltip.style.display = 'block';
            } else {
                // Remove tooltip
                if (tooltip) {
                    tooltip.style.display = 'none';
                }
            }
        }

        function onWindowResize() {
            const container = document.getElementById('canvas-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // Initialize and start
        async function startVisualization() {
            try {
                console.log('Starting visualization...');
                init();
                console.log('Initialized scene');
                
                // Load data from API
                const dataLoaded = await loadDataFromAPI();
                console.log('Data loaded:', dataLoaded);
                if (!dataLoaded) {
                    return; // Error already displayed by loadDataFromAPI
                }
                
                console.log('Creating family...');
                createFamily();
                
                // Create genome legend if genomes are visible
                if (genomesVisible) {
                    createGenomeLegend();
                }
                
                console.log('Starting animation...');
                animate();
                
                // Hide loading screen
                document.getElementById('loading').style.display = 'none';
                console.log('Visualization complete');
            } catch (error) {
                console.error('Error initializing visualization:', error);
                console.error('Stack trace:', error.stack);
                document.getElementById('loading').innerHTML = 'Error loading visualization. Check console for details.<br><br>' + error.message + '<br><br>' + error.stack;
                document.getElementById('loading').style.background = 'rgba(255, 0, 0, 0.7)';
            }
        }

        // Start the visualization
        startVisualization();
    </script>
</body>
</html>
