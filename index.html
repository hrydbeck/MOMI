<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mount Improbable - MOMI</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            overflow: hidden;
        }

        #container {
            width: 100vw;
            height: 100vh;
            display: flex;
        }

        #canvas-container {
            flex: 1;
            position: relative;
        }

        #controls {
            width: 300px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            overflow-y: auto;
            box-shadow: -2px 0 10px rgba(0, 0, 0, 0.2);
        }

        h1 {
            color: #1e3c72;
            font-size: 24px;
            margin-bottom: 10px;
        }

        h2 {
            color: #2a5298;
            font-size: 18px;
            margin-top: 20px;
            margin-bottom: 10px;
        }

        .info {
            background: #e8f4f8;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 15px;
            font-size: 12px;
            line-height: 1.6;
        }

        .legend {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .legend-box {
            width: 30px;
            height: 20px;
            border: 1px solid #333;
        }

        .legend-box.female {
            background: #ff69b4;
            border-radius: 5px;
        }

        .legend-box.male {
            background: #4169e1;
        }

        .person-info {
            background: #f0f0f0;
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            font-size: 13px;
        }

        .person-info h3 {
            color: #1e3c72;
            margin-bottom: 5px;
            font-size: 14px;
        }

        .person-info p {
            margin: 3px 0;
        }

        button {
            background: #2a5298;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 10px;
            width: 100%;
        }

        button:hover {
            background: #1e3c72;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px 40px;
            border-radius: 10px;
        }

        #title-overlay {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 36px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
            z-index: 10;
        }
        
        #title-overlay a {
            color: white;
            text-decoration: none;
            cursor: pointer;
            transition: color 0.3s;
        }
        
        #title-overlay a:hover {
            color: #00ffaa;
            text-shadow: 0 0 10px rgba(0, 255, 170, 0.5);
        }
        
        .event-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            pointer-events: none;
            z-index: 1000;
            font-size: 13px;
            max-width: 250px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
            border: 2px solid #ffaa00;
        }
        
        .event-tooltip h4 {
            margin: 0 0 5px 0;
            font-size: 14px;
        }
        
        .event-tooltip p {
            margin: 3px 0;
            font-size: 12px;
        }
        
        /* Mount Improbable Menu Modal */
        #mi-menu-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }
        
        #mi-menu-modal.visible {
            display: flex;
        }
        
        .mi-menu-content {
            background: linear-gradient(145deg, #1a2a4a 0%, #0a1525 100%);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            max-width: 400px;
            border: 2px solid #00ffaa;
            box-shadow: 0 0 30px rgba(0, 255, 170, 0.3);
        }
        
        .mi-menu-content h2 {
            color: #00ffaa;
            margin-bottom: 10px;
            font-size: 24px;
        }
        
        .mi-menu-content p {
            color: #aaa;
            margin-bottom: 20px;
            font-size: 14px;
        }
        
        .mi-menu-btn {
            display: block;
            width: 100%;
            padding: 15px;
            margin: 10px 0;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
            border: none;
        }
        
        .mi-menu-btn.animation {
            background: linear-gradient(135deg, #00ffaa 0%, #00cc88 100%);
            color: #000;
        }
        
        .mi-menu-btn.animation:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(0, 255, 170, 0.5);
        }
        
        .mi-menu-btn.wiki {
            background: linear-gradient(135deg, #4169e1 0%, #2a4a9a 100%);
            color: white;
        }
        
        .mi-menu-btn.wiki:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(65, 105, 225, 0.5);
        }
        
        .mi-menu-btn.close {
            background: transparent;
            color: #888;
            border: 1px solid #444;
            padding: 10px;
            font-size: 14px;
        }
        
        .mi-menu-btn.close:hover {
            color: #fff;
            border-color: #888;
        }
        
        /* Animation Modal */
        #mi-animation-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 3000;
        }
        
        #mi-animation-modal.visible {
            display: block;
        }
        
        #mi-animation-container {
            width: 100%;
            height: 100%;
        }
        
        #mi-animation-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        
        #mi-animation-title {
            position: absolute;
            bottom: 140px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            opacity: 0;
            transition: opacity 2s;
            color: white;
            z-index: 10;
        }
        
        #mi-animation-title.visible {
            opacity: 1;
        }
        
        #mi-animation-title h1 {
            font-size: 36px;
            font-weight: 300;
            letter-spacing: 4px;
            text-shadow: 0 0 30px rgba(255, 255, 255, 0.5);
            margin-bottom: 10px;
            color: #00ffaa;
        }
        
        #mi-animation-title h2 {
            font-size: 16px;
            font-weight: 300;
            color: #ffaa00;
        }
        
        #mi-narration {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 85%;
            max-width: 900px;
            text-align: center;
            font-size: 22px;
            line-height: 1.7;
            opacity: 0;
            transition: opacity 0.8s;
            text-shadow: 0 0 10px rgba(0, 0, 0, 1);
            background: rgba(0, 0, 0, 0.75);
            padding: 25px 40px;
            border-radius: 12px;
            border: 2px solid rgba(0, 255, 170, 0.3);
            color: white;
        }
        
        #mi-narration.visible {
            opacity: 1;
        }
        
        #mi-timeline-display {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: #ffaa00;
            padding: 15px 30px;
            border-radius: 10px;
            border: 2px solid #ffaa00;
            text-align: center;
            font-size: 28px;
            font-weight: bold;
        }
        
        #mi-close-animation {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid white;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            z-index: 20;
            pointer-events: all;
        }
        
        #mi-close-animation:hover {
            background: rgba(255, 255, 255, 0.4);
        }
        
        #mi-animation-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.85);
            padding: 15px;
            border-radius: 10px;
            pointer-events: all;
            max-width: 280px;
        }
        
        #mi-animation-controls button {
            background: #00ffaa;
            color: #000;
            border: none;
            padding: 8px 12px;
            margin: 2px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            font-size: 12px;
        }
        
        #mi-animation-controls button:hover {
            background: #00dd99;
        }
        
        #mi-animation-controls button.epoch-btn {
            background: #4466aa;
            color: white;
            font-size: 10px;
            padding: 6px 8px;
        }
        
        #mi-animation-controls button.epoch-btn:hover {
            background: #5577bb;
        }
        
        #mi-speed-control {
            margin: 10px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
        }
        
        #mi-speed-control label {
            color: #00ffaa;
            font-size: 12px;
            display: block;
            margin-bottom: 5px;
        }
        
        #mi-speed-slider {
            width: 100%;
            cursor: pointer;
        }
        
        #mi-speed-value {
            color: #ffaa00;
            font-weight: bold;
            font-size: 14px;
        }
        
        .mi-nav-section {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #444;
        }
        
        .mi-nav-section h4 {
            color: #ffaa00;
            font-size: 11px;
            margin-bottom: 5px;
            text-transform: uppercase;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="canvas-container">
            <div id="title-overlay"><span id="mi-title-link" style="cursor: pointer;">Mount Improbable</span></div>
            <div id="loading">Loading 3D Visualization...</div>
            
            <!-- View Mode Indicator -->
            <div id="view-mode-indicator" style="position: absolute; top: 10px; left: 10px; background: rgba(0, 0, 0, 0.7); color: white; padding: 8px 15px; border-radius: 6px; font-weight: bold; font-size: 14px; z-index: 1000;">
                Individual View
            </div>
            
            <!-- Genome Legend Overlay -->
            <div id="genome-legend" style="display: none; position: absolute; top: 10px; right: 10px; background: rgba(255, 255, 255, 0.92); padding: 10px 15px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.25); z-index: 1000; font-size: 12px;">
                <div style="text-align: center; font-weight: bold; font-size: 14px; margin-bottom: 6px; color: #333;">Diploid Genome (2n)</div>
                <div style="display: flex; gap: 10px; justify-content: center; margin-bottom: 5px;">
                    <div style="display: flex; align-items: center; gap: 3px;">
                        <div style="width: 14px; height: 14px; background: #ff4444; border-radius: 2px;"></div>
                        <span style="color: #333; font-weight: bold; font-size: 11px;">A</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 3px;">
                        <div style="width: 14px; height: 14px; background: #44ff44; border-radius: 2px;"></div>
                        <span style="color: #333; font-weight: bold; font-size: 11px;">T</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 3px;">
                        <div style="width: 14px; height: 14px; background: #4444ff; border-radius: 2px;"></div>
                        <span style="color: #333; font-weight: bold; font-size: 11px;">G</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 3px;">
                        <div style="width: 14px; height: 14px; background: #ffff44; border-radius: 2px;"></div>
                        <span style="color: #333; font-weight: bold; font-size: 11px;">C</span>
                    </div>
                </div>
                <div style="display: flex; gap: 12px; justify-content: center; font-size: 11px;">
                    <span style="color: #ff1493; font-weight: bold;">‚ôÄ Maternal</span>
                    <span style="color: #1e90ff; font-weight: bold;">‚ôÇ Paternal</span>
                </div>
            </div>
        </div>
        <div id="controls">
            <h1>MOMI</h1>
            <p style="color: #666; font-size: 12px; margin-bottom: 15px;">
                Motives of Mount Improbable
            </p>

            <div class="info">
                <strong>3D Family Tree - Mount Improbable</strong><br>
                Y-axis: Time (‚Üë top = present, bottom = past)<br>
                X & Z axes: Family positioning<br>
                Height: Lifespan/Age<br>
                <em>Family tree grows upward through time</em>
            </div>

            <h2>Legend</h2>
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-box female"></div>
                    <span>Female (rounded rectangle)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-box male"></div>
                    <span>Male (rectangle)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-box" style="background: #888888;"></div>
                    <span>Deceased (grey, transparent)</span>
                </div>
            </div>

            <h2>Controls</h2>
            <div class="info">
                <strong>Mouse:</strong><br>
                ‚Ä¢ Left click + drag: Rotate view<br>
                ‚Ä¢ Right click + drag: Pan<br>
                ‚Ä¢ Scroll: Zoom in/out<br>
                ‚Ä¢ Click on person: View details
            </div>

            <button id="reset-camera">Reset Camera View</button>
            <button id="toggle-perspective" style="background: #4CAF50; margin-top: 5px;">Enable Perspective</button>
            <button id="toggle-life-events" style="background: #9c27b0; margin-top: 5px;">Hide Life Events</button>
            <button id="toggle-genomes" style="background: #2196f3; margin-top: 5px;">Show Diploid Genomes</button>
            <button id="toggle-environment" style="background: #8bc34a; margin-top: 5px;">Show Environment View</button>
            <button id="toggle-cell-types" style="background: #e91e63; margin-top: 5px;">Show Cell Types</button>

            <h2>Import / Export</h2>
            <div style="display: flex; flex-direction: column; gap: 5px; margin-bottom: 15px;">
                <button id="clear-pedigree-btn" style="background: #f44336;">üóëÔ∏è Clear Pedigree</button>
                <input type="file" id="import-momi" accept=".momi,.zip" style="display: none;">
                <button id="import-momi-btn" style="background: #2196f3;">üì• Import Pedigree (.momi)</button>
                <button id="export-momi-btn" style="background: #4CAF50;">üì§ Export Pedigree (.momi)</button>
            </div>
            <div class="info" style="font-size: 11px;">
                <strong>.momi format:</strong> A zip file containing both pedigree.ped and life_events.tsv<br>
                <em>This ensures all data is imported/exported together</em>
            </div>

            <div id="family-info"></div>
            <div id="person-details"></div>

            <h2>Pedigree Info</h2>
            <div id="pedigree-info" class="info">
                <strong>No pedigree loaded</strong><br>
                Import a .ped file to visualize your family tree.
            </div>
        </div>
    </div>
    
    <!-- Mount Improbable Menu Modal -->
    <div id="mi-menu-modal">
        <div class="mi-menu-content">
            <h2>Mount Improbable</h2>
            <p>Learn about the metaphor that powers this visualization</p>
            <button class="mi-menu-btn animation" onclick="showMIAnimation()">
                üé¨ Watch the Animation
            </button>
            <button class="mi-menu-btn wiki" onclick="window.open('https://en.wikipedia.org/wiki/Climbing_Mount_Improbable', '_blank'); closeMIMenu();">
                üìñ Read on Wikipedia
            </button>
            <button class="mi-menu-btn close" onclick="closeMIMenu()">
                Close
            </button>
        </div>
    </div>
    
    <!-- Mount Improbable Animation Modal -->
    <div id="mi-animation-modal">
        <div id="mi-animation-container"></div>
        <div id="mi-animation-overlay">
            <div id="mi-animation-title">
                <h1>MOUNT IMPROBABLE</h1>
                <h2>3.8 Billion Years of Life on Earth</h2>
            </div>
            <div id="mi-narration"></div>
            <div id="mi-timeline-display">Present Day</div>
            <button id="mi-close-animation" onclick="closeMIAnimation()">‚úï Close</button>
            <div id="mi-animation-controls">
                <button onclick="miAnimationRestart()">‚Üª Restart</button>
                <button onclick="miAnimationToggle()" id="mi-play-btn">‚è∏ Pause</button>
                
                <div id="mi-speed-control">
                    <label>‚ö° Speed: <span id="mi-speed-value">1x</span></label>
                    <input type="range" id="mi-speed-slider" min="0.1" max="5" step="0.1" value="1" 
                           onchange="setMISpeed(this.value)" oninput="updateSpeedDisplay(this.value)">
                </div>
                
                <div class="mi-nav-section">
                    <h4>üïê Jump to Era</h4>
                    <button class="epoch-btn" onclick="jumpToEpoch(0)">Present</button>
                    <button class="epoch-btn" onclick="jumpToEpoch(-13)">K-Pg (66Ma)</button>
                    <button class="epoch-btn" onclick="jumpToEpoch(-40)">Triassic (200Ma)</button>
                    <button class="epoch-btn" onclick="jumpToEpoch(-108)">Cambrian (541Ma)</button>
                    <button class="epoch-btn" onclick="jumpToEpoch(-120)">üß¨ Sex (1.2Ga)</button>
                    <button class="epoch-btn" onclick="jumpToEpoch(-240)">Eukaryotes (2.1Ga)</button>
                    <button class="epoch-btn" onclick="jumpToEpoch(-380)">üî¨ Origin of Life</button>
                </div>
                
                <div class="mi-nav-section">
                    <h4>üíÄ Mass Extinctions</h4>
                    <button class="epoch-btn" onclick="jumpToEpoch(-13)">K-Pg (Dinos)</button>
                    <button class="epoch-btn" onclick="jumpToEpoch(-50)">Permian (252Ma)</button>
                    <button class="epoch-btn" onclick="jumpToEpoch(-72)">Devonian (375Ma)</button>
                    <button class="epoch-btn" onclick="jumpToEpoch(-86)">Ordovician (445Ma)</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <script>

        // Configuration
        const PERSON_WIDTH = 1;
        const PERSON_DEPTH = 1;
        const YEAR_SCALE = 0.1; // 1 year = 0.1 units in 3D space
        const CURRENT_YEAR = 2025;
        const OLDEST_YEAR = 1930; // Reference point for the bottom of the timeline
        
        // Evolutionary perspective - fictional origin point for visualization
        const ORIGIN_YEAR = OLDEST_YEAR - 20; // 20 years before oldest person (1910)
        const VANISHING_POINT = { x: 0, z: 0 }; // All lineages converge here
        let perspectiveEnabled = false; // Toggle for perspective view (disabled by default)
        let lifeEventsVisible = true; // Toggle for life events visibility

        // Scene setup
        let scene, camera, renderer, controls;
        let selectedPerson = null;
        let selectedFamily = null; // 'smith', 'chen', or null for all
        const personMeshes = new Map(); // Map person ID to mesh
        const conceptionLines = []; // Store conception line objects
        const lifeEventMarkers = []; // Store life event markers and lines
        const genomeVisualizations = []; // Store genome visualizations
        let genomesVisible = false; // Toggle for genome visibility
        let genomeLegend = null; // Store reference to genome legend sprite
        let environmentView = false; // Toggle for environment vs individual view
        
        // Cell type visualization
        const cellTypeVisualizations = []; // Store cell type substacks
        let cellTypesVisible = false; // Toggle for cell types visibility
        
        // Cell type definitions - uses shade multipliers applied to person's base color
        // Germline is included as a special cell type (the reproductive lineage)
        const CELL_TYPES = [
            { name: 'Epithelial', shadeMultiplier: 1.0 },    // Base color
            { name: 'Muscle', shadeMultiplier: 0.7 },        // Darker
            { name: 'Nerve', shadeMultiplier: 1.3 },         // Lighter
            { name: 'Blood', shadeMultiplier: 0.85 },        // Slightly darker
            { name: 'Bone', shadeMultiplier: 1.5 },          // Much lighter
            { name: 'Adipose', shadeMultiplier: 1.15 },      // Slightly lighter
            { name: 'Connective', shadeMultiplier: 0.55 },   // Much darker
            { name: 'Immune', shadeMultiplier: 0.9 },        // Slightly darker
            { name: 'Germline', shadeMultiplier: 1.0, isGermline: true }  // Special - reproductive cells
        ];
        
        // Family member IDs (populated from API)
        let familyMembers = {};
        
        // Apply perspective convergence to X/Z positions
        // Linear interpolation: at CURRENT_YEAR = full position, at ORIGIN_YEAR = vanishing point
        function applyPerspective(x, z, year) {
            if (!perspectiveEnabled) {
                // No perspective - return original positions
                return { x: x, z: z, scale: 1.0 };
            }
            
            // Calculate how far we are from origin to present
            const totalYears = CURRENT_YEAR - ORIGIN_YEAR;
            const yearFromOrigin = year - ORIGIN_YEAR;
            
            // Scale factor: 0 at origin, 1 at present
            const scale = Math.max(0, Math.min(1, yearFromOrigin / totalYears));
            
            // Positions converge toward vanishing point as we go back in time
            const perspectiveX = VANISHING_POINT.x + (x - VANISHING_POINT.x) * scale;
            const perspectiveZ = VANISHING_POINT.z + (z - VANISHING_POINT.z) * scale;
            
            return { x: perspectiveX, z: perspectiveZ, scale };
        }

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a2332);
            scene.fog = new THREE.Fog(0x1a2332, 10, 50);

            // Camera
            const container = document.getElementById('canvas-container');
            camera = new THREE.PerspectiveCamera(
                60,
                container.clientWidth / container.clientHeight,
                0.1,
                1000
            );
            camera.position.set(15, 10, 15);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);

            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 5;
            controls.maxDistance = 50;

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -20;
            directionalLight.shadow.camera.right = 20;
            directionalLight.shadow.camera.top = 20;
            directionalLight.shadow.camera.bottom = -20;
            scene.add(directionalLight);

            // Grid helper at bottom (past)
            const gridHelper = new THREE.GridHelper(30, 30, 0x444444, 0x222222);
            gridHelper.position.y = 0;
            scene.add(gridHelper);

            // Add grid at present (top)
            addPresentGrid();

            // Axes helper at origin of life (when perspective enabled) or at 0,0,0
            const axesHelper = new THREE.AxesHelper(5);
            if (perspectiveEnabled) {
                const originHeight = (ORIGIN_YEAR - OLDEST_YEAR) * YEAR_SCALE;
                axesHelper.position.set(VANISHING_POINT.x, originHeight, VANISHING_POINT.z);
            }
            scene.add(axesHelper);

            // Add axis labels
            addAxisLabels();
            
            // Add visible Y-axis with year markings
            addTimeAxis();

            // Handle window resize
            window.addEventListener('resize', onWindowResize);

            // Mouse click for selection
            renderer.domElement.addEventListener('click', onMouseClick);

            // Reset camera button
            document.getElementById('reset-camera').addEventListener('click', resetCamera);
            
            // Perspective toggle button
            document.getElementById('toggle-perspective').addEventListener('click', togglePerspective);
            
            // Life events toggle button
            document.getElementById('toggle-life-events').addEventListener('click', toggleLifeEvents);
            
            // Genome toggle button
            document.getElementById('toggle-genomes').addEventListener('click', toggleGenomes);
            document.getElementById('toggle-environment').addEventListener('click', toggleEnvironment);
            
            // Cell types toggle button
            document.getElementById('toggle-cell-types').addEventListener('click', toggleCellTypes);
            
            // Import/Export buttons
            document.getElementById('clear-pedigree-btn').addEventListener('click', clearPedigree);
            document.getElementById('import-momi-btn').addEventListener('click', () => document.getElementById('import-momi').click());
            document.getElementById('import-momi').addEventListener('change', handleMomiImport);
            document.getElementById('export-momi-btn').addEventListener('click', exportMomiFile);
            
            // Mouse move for hover tooltips
            renderer.domElement.addEventListener('mousemove', onMouseMove);

            // Hide loading message
            document.getElementById('loading').style.display = 'none';
        }

        function addAxisLabels() {
            const loader = new THREE.FontLoader();
            // For simplicity, using sprites with text textures
            const createTextLabel = (text, position, color = 0xffffff) => {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 512;
                canvas.height = 128;
                context.fillStyle = `#${color.toString(16).padStart(6, '0')}`;
                context.font = 'Bold 48px Arial';
                context.textAlign = 'center';
                context.fillText(text, 256, 80);

                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.position.copy(position);
                sprite.scale.set(4, 1, 1);
                scene.add(sprite);
            };

            // Y-axis label at "now" (present)
            const presentHeight = (CURRENT_YEAR - OLDEST_YEAR) * YEAR_SCALE;
            createTextLabel('Time (Y) ‚Üë NOW', new THREE.Vector3(0, presentHeight + 1, 0), 0x00ff00);
            
            // X and Z axis labels
            createTextLabel('X (Family Position)', new THREE.Vector3(8, 0, 0), 0xff0000);
            createTextLabel('Z (Generations)', new THREE.Vector3(0, 0, 8), 0x0000ff);
        }

        function addPresentGrid() {
            // Calculate height of present (2025)
            const presentHeight = (CURRENT_YEAR - OLDEST_YEAR) * YEAR_SCALE;
            
            // Create a semi-transparent grid at the present level
            const gridHelper = new THREE.GridHelper(30, 30, 0x00ff88, 0x00aa66);
            gridHelper.position.y = presentHeight;
            scene.add(gridHelper);
            
            // Add a glowing plane to make it more visible
            const planeGeometry = new THREE.PlaneGeometry(30, 30);
            const planeMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00ffaa,
                transparent: true,
                opacity: 0.1,
                side: THREE.DoubleSide
            });
            const plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.rotation.x = Math.PI / 2;
            plane.position.y = presentHeight;
            scene.add(plane);
            
            // Add a border/outline for the present plane
            const edgesGeometry = new THREE.EdgesGeometry(planeGeometry);
            const edgesMaterial = new THREE.LineBasicMaterial({ 
                color: 0x00ffff,
                linewidth: 2
            });
            const edges = new THREE.LineSegments(edgesGeometry, edgesMaterial);
            edges.rotation.x = Math.PI / 2;
            edges.position.y = presentHeight;
            scene.add(edges);
            
            // Add "ORIGIN OF LIFE" label at the far end (bottom of mountain)
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 512;
            canvas.height = 128;
            context.fillStyle = '#ffffff';
            context.font = 'Bold 48px Arial';
            context.textAlign = 'center';
            context.fillText('ORIGIN OF LIFE', 256, 60);
            context.font = '24px Arial';
            context.fillStyle = '#00ffaa';
            context.fillText('3.8 Billion Years Ago', 256, 100);

            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            // Position at far end - origin of life (using perspective origin point)
            const originHeight = (ORIGIN_YEAR - OLDEST_YEAR) * YEAR_SCALE;
            sprite.position.set(0, originHeight - 2, 0);
            sprite.scale.set(6, 1.5, 1);
            scene.add(sprite);
        }

        function addTimeAxis() {
            // Base position for axis (will be adjusted with perspective)
            const baseX = -6;
            const baseZ = -6;
            
            // Create vertical axis line - bottom (origin/past) to top (present)
            const presentHeight = (CURRENT_YEAR - OLDEST_YEAR) * YEAR_SCALE;
            const bottomHeight = perspectiveEnabled ? (ORIGIN_YEAR - OLDEST_YEAR) * YEAR_SCALE : 0;
            
            // Apply perspective to axis endpoints
            const bottomYear = perspectiveEnabled ? ORIGIN_YEAR : OLDEST_YEAR;
            const bottomPos = applyPerspective(baseX, baseZ, bottomYear);
            const topPos = applyPerspective(baseX, baseZ, CURRENT_YEAR);
            
            const axisPoints = [
                new THREE.Vector3(bottomPos.x, bottomHeight, bottomPos.z),
                new THREE.Vector3(topPos.x, presentHeight, topPos.z)
            ];
            const axisGeometry = new THREE.BufferGeometry().setFromPoints(axisPoints);
            const axisMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 });
            const axisLine = new THREE.Line(axisGeometry, axisMaterial);
            scene.add(axisLine);

            // Add year labels every 10 years
            const createYearLabel = (year, yPosition) => {
                // Apply perspective to label position
                const labelPos = applyPerspective(baseX - 1, baseZ, year);
                
                // Scale based on perspective - older years appear smaller
                const scaleFactor = perspectiveEnabled ? labelPos.scale : 1.0;
                
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 128;
                canvas.height = 64;
                context.fillStyle = '#ffffff';
                context.font = 'Bold 32px Arial';
                context.textAlign = 'right';
                context.fillText(year.toString(), 120, 45);

                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.position.set(labelPos.x, yPosition, labelPos.z);
                sprite.scale.set(1.5 * scaleFactor, 0.75 * scaleFactor, 1);
                scene.add(sprite);
                
                // Add tick mark with perspective
                const tickPos = applyPerspective(baseX, baseZ, year);
                const tickEndPos = applyPerspective(baseX - 0.3, baseZ, year);
                
                const tickPoints = [
                    new THREE.Vector3(tickPos.x, yPosition, tickPos.z),
                    new THREE.Vector3(tickEndPos.x, yPosition, tickEndPos.z)
                ];
                const tickGeometry = new THREE.BufferGeometry().setFromPoints(tickPoints);
                const tickMaterial = new THREE.LineBasicMaterial({ color: 0xffffff });
                const tick = new THREE.Line(tickGeometry, tickMaterial);
                scene.add(tick);
            };

            // Calculate year range
            const yearsToShow = [1940, 1950, 1960, 1970, 1980, 1990, 2000, 2010, 2020, CURRENT_YEAR];
            
            yearsToShow.forEach(year => {
                const yPosition = (year - OLDEST_YEAR) * YEAR_SCALE;
                createYearLabel(year, yPosition);
            });
        }

        function createRoundedBoxGeometry(width, height, depth, radius, smoothness) {
            // Create a shape for rounded rectangle (viewed from above)
            const shape = new THREE.Shape();
            const x = -width / 2;
            const y = -depth / 2;
            const w = width;
            const h = depth;
            const r = radius;
            
            shape.moveTo(x + r, y);
            shape.lineTo(x + w - r, y);
            shape.quadraticCurveTo(x + w, y, x + w, y + r);
            shape.lineTo(x + w, y + h - r);
            shape.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
            shape.lineTo(x + r, y + h);
            shape.quadraticCurveTo(x, y + h, x, y + h - r);
            shape.lineTo(x, y + r);
            shape.quadraticCurveTo(x, y, x + r, y);
            
            const extrudeSettings = {
                depth: height,
                bevelEnabled: false
            };
            
            const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            geometry.rotateX(Math.PI / 2);
            geometry.translate(0, height / 2, 0);
            
            return geometry;
        }
        
        // Create a tapered geometry where edges point toward the vanishing point
        function createTaperedPersonGeometry(x, z, birthYear, deathYear, sex, height) {
            const birthPerspective = applyPerspective(x, z, birthYear);
            const topYear = deathYear || CURRENT_YEAR;
            const topPerspective = applyPerspective(x, z, topYear);
            
            // Calculate the offset from origin for bottom and top
            const bottomOffsetX = birthPerspective.x - VANISHING_POINT.x;
            const bottomOffsetZ = birthPerspective.z - VANISHING_POINT.z;
            const topOffsetX = topPerspective.x - VANISHING_POINT.x;
            const topOffsetZ = topPerspective.z - VANISHING_POINT.z;
            
            // Create custom geometry with vertices
            const geometry = new THREE.BufferGeometry();
            
            const hw = PERSON_WIDTH / 2;
            const hd = PERSON_DEPTH / 2;
            const hh = height / 2;
            
            // Calculate scale factors for top and bottom based on distance from origin
            const bottomScale = birthPerspective.scale;
            const topScale = topPerspective.scale;
            
            const vertices = new Float32Array([
                // Bottom face (smaller, closer to origin)
                -hw * bottomScale, -hh, -hd * bottomScale,
                 hw * bottomScale, -hh, -hd * bottomScale,
                 hw * bottomScale, -hh,  hd * bottomScale,
                -hw * bottomScale, -hh,  hd * bottomScale,
                
                // Top face (larger, further from origin)
                -hw * topScale, hh, -hd * topScale,
                 hw * topScale, hh, -hd * topScale,
                 hw * topScale, hh,  hd * topScale,
                -hw * topScale, hh,  hd * topScale,
            ]);
            
            const indices = new Uint16Array([
                // Bottom
                0, 2, 1, 0, 3, 2,
                // Top
                4, 5, 6, 4, 6, 7,
                // Sides
                0, 1, 5, 0, 5, 4,
                1, 2, 6, 1, 6, 5,
                2, 3, 7, 2, 7, 6,
                3, 0, 4, 3, 4, 7,
            ]);
            
            geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
            geometry.setIndex(new THREE.BufferAttribute(indices, 1));
            geometry.computeVertexNormals();
            
            return geometry;
        }

        function createPerson(data) {
            const { id, name, sex, birthYear, birthMonth = 6, deathYear, x, z, motherId } = data;
            
            // Calculate Y position and height (including months for precision)
            // Present is at TOP (high Y), past at BOTTOM (low Y) - building Mount Improbable upward
            const birthDecimal = birthYear + (birthMonth - 1) / 12;
            const conceptionDecimal = birthDecimal - (9/12); // 9 months before birth
            const currentAge = deathYear ? 
                (deathYear - birthDecimal) : 
                (CURRENT_YEAR + 11/12 - birthDecimal); // Current month assumed as Dec
            const height = currentAge * YEAR_SCALE;
            const birthHeight = (birthDecimal - OLDEST_YEAR) * YEAR_SCALE; // Birth position from bottom
            const yPosition = birthHeight + height / 2; // Center of the box (birth + half height)
            
            // Apply evolutionary perspective - positions converge toward origin of life
            const birthPerspective = applyPerspective(x, z, birthDecimal);
            const deathOrCurrentYear = deathYear || CURRENT_YEAR;
            const topPerspective = applyPerspective(x, z, deathOrCurrentYear);

            // Create tapered geometry pointing toward origin
            const geometry = createTaperedPersonGeometry(x, z, birthDecimal, deathOrCurrentYear, sex, height);
            
            // Create material based on sex and living status
            let color;
            if (deathYear) {
                // Deceased - grey color
                color = 0x888888;
            } else {
                // Living - normal colors
                color = sex === 'F' ? 0xff69b4 : 0x4169e1; // Pink for female, blue for male
            }
            
            const material = new THREE.MeshPhongMaterial({ 
                color: color,
                shininess: 30,
                transparent: true,
                opacity: deathYear ? 0.6 : 0.9  // More transparent if deceased
            });

            const mesh = new THREE.Mesh(geometry, material);
            
            // Calculate the angle to tilt the stack toward origin point (below in the past)
            // The stack should lean downward and inward so bottom points toward the vanishing point
            const bottomPos = new THREE.Vector3(birthPerspective.x, birthHeight, birthPerspective.z);
            const topPos = new THREE.Vector3(topPerspective.x, birthHeight + height, topPerspective.z);
            const centerPos = new THREE.Vector3(
                (birthPerspective.x + topPerspective.x) / 2,
                yPosition,
                (birthPerspective.z + topPerspective.z) / 2
            );
            
            // Calculate the origin point position in 3D space
            const originHeight = (ORIGIN_YEAR - OLDEST_YEAR) * YEAR_SCALE;
            const originPoint = new THREE.Vector3(VANISHING_POINT.x, originHeight, VANISHING_POINT.z);
            
            // Vector from stack bottom to origin point
            const toOrigin = new THREE.Vector3().subVectors(originPoint, bottomPos);
            const distance = toOrigin.length();
            
            // Calculate rotation to point the stack axis toward origin
            // Stack should tilt so its bottom edge points toward origin point
            const horizontalDist = Math.sqrt(
                (centerPos.x - VANISHING_POINT.x) ** 2 + 
                (centerPos.z - VANISHING_POINT.z) ** 2
            );
            const verticalDist = Math.abs(originHeight - yPosition);
            
            // Tilt angles to make stack point toward origin
            const tiltAmount = perspectiveEnabled ? Math.atan2(horizontalDist, verticalDist) : 0;
            const tiltFactor = 0.6; // Increased for more visible effect
            
            // Calculate direction-based tilts (inverted to point toward, not away)
            const xTilt = tiltAmount * tiltFactor * (centerPos.z - VANISHING_POINT.z) / (horizontalDist + 0.1);
            const zTilt = -tiltAmount * tiltFactor * (centerPos.x - VANISHING_POINT.x) / (horizontalDist + 0.1);
            
            // Apply position and rotation
            mesh.position.set(centerPos.x, centerPos.y, centerPos.z);
            mesh.rotation.x = xTilt;
            mesh.rotation.z = zTilt;
            
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            // Store perspective data for later use
            mesh.userData.birthPerspective = birthPerspective;
            mesh.userData.topPerspective = topPerspective;

            if (sex === 'F' && !deathYear) {
                // Add subtle emissive glow to living females
                material.emissive = new THREE.Color(0xff1493);
                material.emissiveIntensity = 0.1;
            }

            // Store reference to person data
            mesh.userData = data;
            mesh.userData.x = x; // Store original x for perspective calculations
            mesh.userData.z = z; // Store original z for perspective calculations
            mesh.userData.birthHeight = birthHeight;
            mesh.userData.conceptionHeight = (conceptionDecimal - OLDEST_YEAR) * YEAR_SCALE;

            personMeshes.set(id, mesh);
            scene.add(mesh);

            // Add germline substack (reproductive cells - where gametes come from)
            const germlineHeight = height * 0.9; // Germline runs most of the body height
            const germlineWidth = PERSON_WIDTH * 0.15; // Thin central line
            const germlineDepth = PERSON_DEPTH * 0.15;
            
            // Create tapered germline
            const germlineStartYear = birthDecimal + (currentAge * 0.05); // Start slightly after birth
            const germlineEndYear = deathOrCurrentYear - (currentAge * 0.05); // End slightly before top
            const germlineGeometry = createTaperedPersonGeometry(
                x, z, germlineStartYear, germlineEndYear, sex, germlineHeight
            );
            
            // Scale down the germline
            germlineGeometry.scale(0.15, 1, 0.15);
            const germlineMaterial = new THREE.MeshPhongMaterial({
                color: 0xffaa00, // Orange/gold for germline
                shininess: 30,
                transparent: true,
                opacity: 0.4, // More subtle
                emissive: new THREE.Color(0xffaa00),
                emissiveIntensity: 0.1 // Reduced glow
            });
            
            const germlineMesh = new THREE.Mesh(germlineGeometry, germlineMaterial);
            germlineMesh.position.copy(mesh.position); // Same position as main mesh
            germlineMesh.rotation.copy(mesh.rotation); // Same rotation as main mesh
            germlineMesh.userData = { isGermline: true, personId: id };
            scene.add(germlineMesh);
            
            // Store germline position for conception connections
            mesh.userData.germlinePosition = { 
                x: centerPos.x, 
                y: centerPos.y, 
                z: centerPos.z 
            };

            // Add gestation period visualization (9 months growing inside mother)
            if (motherId) {
                addGestationStack(data, mesh.userData.conceptionHeight, birthHeight, color, birthPerspective);
            }

            // Add name label at the center of the stack
            addNameLabel(name, centerPos.x, centerPos.y + height / 2 + 0.5, centerPos.z);
            
            // Add life events markers (only in individual view)
            if (!environmentView) {
                addLifeEventsMarkers(id, x, z, birthDecimal, deathOrCurrentYear, birthHeight, height, centerPos, mesh.rotation);
            }
            
            // Create genome visualization (only in individual view, hidden by default)
            if (!environmentView) {
                addDiploidGenomeVisualization(id, centerPos, height, sex, motherId, data.fatherId);
            }
            
            // Create cell type visualization (only in individual view, hidden by default)
            if (!environmentView) {
                addCellTypeVisualization(id, centerPos, height, mesh.rotation, birthDecimal, deathOrCurrentYear, x, z, sex);
            }

            return mesh;
        }
        
        function addDiploidGenomeVisualization(personId, centerPos, personHeight, sex, motherId, fatherId) {
            // Create compact genome visualization as small colored squares inside the person stack
            const genomeGroup = new THREE.Group();
            
            const numBars = 20; // Number of squares per chromosome
            const squareSize = 0.04;
            const squareGap = 0.005;
            const chromSpacing = 0.06; // Space between maternal and paternal
            
            // Four DNA base colors: Adenine (red), Thymine (green), Guanine (blue), Cytosine (yellow)
            const baseColors = [
                0xff4444, // A - Red
                0x44ff44, // T - Green  
                0x4444ff, // G - Blue
                0xffff44  // C - Yellow
            ];
            
            const baseNames = ['A', 'T', 'G', 'C'];
            
            // Generate random genome sequence (in real use, this would come from actual genetic data)
            function generateRandomGenome(length) {
                const genome = [];
                for (let i = 0; i < length; i++) {
                    genome.push(Math.floor(Math.random() * 4));
                }
                return genome;
            }
            
            const maternalGenome = generateRandomGenome(numBars);
            const paternalGenome = generateRandomGenome(numBars);
            
            // Store genome data for genome browser
            const genomeData = {
                personId: personId,
                maternal: maternalGenome,
                paternal: paternalGenome,
                baseColors: baseColors,
                baseNames: baseNames
            };
            
            // Create maternal chromosome (left column)
            for (let i = 0; i < numBars; i++) {
                const baseIndex = maternalGenome[i];
                const color = baseColors[baseIndex];
                
                const geometry = new THREE.BoxGeometry(squareSize, squareSize, squareSize);
                const material = new THREE.MeshPhongMaterial({ 
                    color: color,
                    emissive: color,
                    emissiveIntensity: 0.4
                });
                
                const square = new THREE.Mesh(geometry, material);
                square.position.set(
                    -chromSpacing / 2,
                    i * (squareSize + squareGap) - (numBars * (squareSize + squareGap)) / 2,
                    0
                );
                genomeGroup.add(square);
            }
            
            // Create paternal chromosome (right column)
            for (let i = 0; i < numBars; i++) {
                const baseIndex = paternalGenome[i];
                const color = baseColors[baseIndex];
                
                const geometry = new THREE.BoxGeometry(squareSize, squareSize, squareSize);
                const material = new THREE.MeshPhongMaterial({ 
                    color: color,
                    emissive: color,
                    emissiveIntensity: 0.4
                });
                
                const square = new THREE.Mesh(geometry, material);
                square.position.set(
                    chromSpacing / 2,
                    i * (squareSize + squareGap) - (numBars * (squareSize + squareGap)) / 2,
                    0
                );
                genomeGroup.add(square);
            }
            
            // Position the genome group inside the person stack (slightly forward)
            genomeGroup.position.set(
                centerPos.x,
                centerPos.y,
                centerPos.z + 0.35
            );
            
            genomeGroup.visible = genomesVisible;
            genomeGroup.userData = {
                isGenome: true,
                personId: personId,
                genomeData: genomeData
            };
            
            scene.add(genomeGroup);
            genomeVisualizations.push(genomeGroup);
        }
        
        function createGenomeLegend() {
            // Remove existing legend if any
            if (genomeLegend) {
                scene.remove(genomeLegend);
                genomeLegend = null;
            }
            
            console.log('Creating genome legend...');
            
            // Create a legend sprite showing genome information
            const canvas = document.createElement('canvas');
            canvas.width = 320;
            canvas.height = 140;
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = '#000000';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Diploid Genome (2n)', canvas.width/2, 25);
            
            // Color legend for DNA bases
            ctx.font = '16px Arial';
            const legendY = 50;
            const spacing = 70;
            
            // Draw legend boxes and labels
            const legendColors = [
                {color: '#ff4444', label: 'A', x: 20},
                {color: '#44ff44', label: 'T', x: 20 + spacing},
                {color: '#4444ff', label: 'G', x: 20 + spacing * 2},
                {color: '#ffff44', label: 'C', x: 20 + spacing * 3}
            ];
            
            legendColors.forEach(item => {
                ctx.fillStyle = item.color;
                ctx.fillRect(item.x, legendY, 15, 15);
                ctx.fillStyle = '#000000';
                ctx.fillText(item.label, item.x + 27, legendY + 12);
            });
            
            ctx.font = '18px Arial';
            ctx.fillStyle = '#ff1493';
            ctx.fillText('‚ôÄ Maternal', canvas.width/2 - 60, 95);
            ctx.fillStyle = '#1e90ff';
            ctx.fillText('‚ôÇ Paternal', canvas.width/2 + 60, 95);
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ 
                map: texture,
                transparent: true,
                opacity: 0.95
            });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(8, 3.5, 1); // Much larger
            sprite.position.set(0, 30, 0); // Center, high up
            
            console.log('Legend created at position:', sprite.position);
            console.log('Legend scale:', sprite.scale);
            console.log('Legend visible:', sprite.visible);
            
            sprite.visible = true; // Always visible when created
            sprite.userData = { isGenomeLegend: true };
            
            scene.add(sprite);
            genomeLegend = sprite; // Store reference separately
            console.log('Legend added to scene, total children:', scene.children.length);
        }
        
        function addCellTypeVisualization(personId, centerPos, height, rotation, birthDecimal, deathOrCurrentYear, x, z, sex) {
            // Create cell type substacks arranged in a grid in the X-Z plane
            // Uses shades of the person's base color (pink for female, blue for male)
            const cellTypeGroup = new THREE.Group();
            
            // Base color based on sex
            const baseColor = sex === 'F' ? new THREE.Color(0xff69b4) : new THREE.Color(0x4169e1);
            
            // Grid layout: 3 columns (X) x 3 rows (Z) = 9 cell types
            const gridCols = 3;
            const gridRows = 3;
            const numCellTypes = CELL_TYPES.length; // 9 including germline
            
            const totalWidth = PERSON_WIDTH * 0.9;  // Use 90% of person width
            const totalDepth = PERSON_DEPTH * 0.9;  // Use 90% of person depth
            const cellWidth = totalWidth / gridCols;
            const cellDepth = totalDepth / gridRows;
            const barHeight = height;
            
            // Helper function to apply shade multiplier to a color
            function applyShade(color, multiplier) {
                const hsl = {};
                color.getHSL(hsl);
                // Adjust lightness based on multiplier
                const newLightness = Math.min(1, Math.max(0, hsl.l * multiplier));
                return new THREE.Color().setHSL(hsl.h, hsl.s, newLightness);
            }
            
            for (let i = 0; i < numCellTypes; i++) {
                const cellType = CELL_TYPES[i];
                const col = i % gridCols;
                const row = Math.floor(i / gridCols);
                
                // Calculate position in grid
                const xOffset = -totalWidth / 2 + cellWidth / 2 + col * cellWidth;
                const zOffset = -totalDepth / 2 + cellDepth / 2 + row * cellDepth;
                
                // Create box geometry for this cell type
                const barGeometry = new THREE.BoxGeometry(
                    cellWidth * 0.9,  // Slight gap between cells
                    barHeight,
                    cellDepth * 0.9
                );
                
                // Determine color - germline is special (orange/gold), others use shade of base
                let cellColor;
                let emissiveColor = null;
                let emissiveIntensity = 0;
                
                if (cellType.isGermline) {
                    // Germline uses distinctive orange/gold color with glow
                    cellColor = new THREE.Color(0xffaa00);
                    emissiveColor = new THREE.Color(0xffaa00);
                    emissiveIntensity = 0.3;
                } else {
                    // Apply shade multiplier to base color
                    cellColor = applyShade(baseColor.clone(), cellType.shadeMultiplier);
                }
                
                const barMaterial = new THREE.MeshPhongMaterial({
                    color: cellColor,
                    transparent: true,
                    opacity: 0.75,
                    shininess: 30,
                    depthWrite: false
                });
                
                if (emissiveColor) {
                    barMaterial.emissive = emissiveColor;
                    barMaterial.emissiveIntensity = emissiveIntensity;
                }
                
                const bar = new THREE.Mesh(barGeometry, barMaterial);
                
                // Position in grid
                bar.position.set(xOffset, 0, zOffset);
                
                bar.userData = {
                    isCellType: true,
                    cellTypeName: cellType.name,
                    personId: personId,
                    isGermline: cellType.isGermline || false
                };
                
                cellTypeGroup.add(bar);
            }
            
            // Position and rotate the group to match the person
            cellTypeGroup.position.copy(centerPos);
            cellTypeGroup.rotation.copy(rotation);
            
            cellTypeGroup.visible = cellTypesVisible;
            cellTypeGroup.userData = {
                isCellTypeGroup: true,
                personId: personId
            };
            cellTypeGroup.renderOrder = 5; // Render on top of person mesh
            
            scene.add(cellTypeGroup);
            cellTypeVisualizations.push(cellTypeGroup);
        }
        
        function toggleCellTypes() {
            cellTypesVisible = !cellTypesVisible;
            
            // Update button text
            const button = document.getElementById('toggle-cell-types');
            button.textContent = cellTypesVisible ? 'Hide Cell Types' : 'Show Cell Types';
            button.style.background = cellTypesVisible ? '#e91e63' : '#4CAF50';
            
            // Toggle visibility of all cell type visualizations
            cellTypeVisualizations.forEach(group => {
                group.visible = cellTypesVisible;
            });
        }

        function addLifeEventsMarkers(personId, x, z, birthDecimal, topYear, birthHeight, personHeight, centerPos, rotation) {
            // Get all life events for this person
            const personEvents = lifeEvents.filter(event => event.personId === personId);
            
            if (personEvents.length === 0) return;
            
            personEvents.forEach(event => {
                const eventYear = event.onsetYear + 0.5; // Mid-year
                
                // Skip if event is outside person's lifetime
                if (eventYear < birthDecimal || eventYear > topYear) return;
                
                // Calculate Y position of event on the person's timeline
                const eventHeight = (eventYear - OLDEST_YEAR) * YEAR_SCALE;
                
                // Apply perspective to event position
                const eventPerspective = applyPerspective(x, z, eventYear);
                
                // Determine marker color and size based on event type and severity
                let markerColor, markerSize;
                switch (event.severity) {
                    case 'severe':
                        markerColor = 0xff0000; // Red
                        markerSize = 0.4;
                        break;
                    case 'moderate':
                        markerColor = 0xff9900; // Orange
                        markerSize = 0.3;
                        break;
                    case 'mild':
                        markerColor = 0xffff00; // Yellow
                        markerSize = 0.25;
                        break;
                    case 'positive':
                        markerColor = 0x00ff00; // Green
                        markerSize = 0.3;
                        break;
                    default:
                        markerColor = 0xffffff; // White
                        markerSize = 0.25;
                }
                
                // Create marker sphere
                const markerGeometry = new THREE.SphereGeometry(markerSize, 16, 16);
                const markerMaterial = new THREE.MeshPhongMaterial({
                    color: markerColor,
                    emissive: markerColor,
                    emissiveIntensity: 0.5,
                    transparent: true,
                    opacity: 0.9
                });
                const marker = new THREE.Mesh(markerGeometry, markerMaterial);
                
                // Position marker at the side of the person stack
                const offsetDistance = 1.2;
                marker.position.set(
                    eventPerspective.x + offsetDistance,
                    eventHeight,
                    eventPerspective.z
                );
                
                // Store event data
                marker.userData = {
                    isLifeEvent: true,
                    personId: personId,
                    event: event
                };
                
                marker.visible = lifeEventsVisible;
                scene.add(marker);
                lifeEventMarkers.push(marker);
                
                // Add connecting line from marker to person stack
                const linePoints = [
                    new THREE.Vector3(centerPos.x, eventHeight, centerPos.z),
                    new THREE.Vector3(eventPerspective.x + offsetDistance, eventHeight, eventPerspective.z)
                ];
                const lineGeometry = new THREE.BufferGeometry().setFromPoints(linePoints);
                const lineMaterial = new THREE.LineBasicMaterial({
                    color: markerColor,
                    transparent: true,
                    opacity: 0.5
                });
                const line = new THREE.Line(lineGeometry, lineMaterial);
                line.visible = lifeEventsVisible;
                scene.add(line);
                lifeEventMarkers.push(line);
            });
        }

        function addGestationStack(data, conceptionHeight, birthHeight, childColor, childPerspective) {
            const { motherId, sex, birthYear, birthMonth = 6 } = data;
            
            const mother = personMeshes.get(motherId);
            if (!mother) return;
            
            const gestationHeight = birthHeight - conceptionHeight; // 9 months
            const birthDecimal = birthYear + (birthMonth - 1) / 12;
            const conceptionDecimal = birthDecimal - (9/12);
            
            // Create a tapered geometry that grows from a point to full size
            // We'll use multiple segments to create the growing effect
            const segments = 10;
            const segmentHeight = gestationHeight / segments;
            
            for (let i = 0; i < segments; i++) {
                const t = i / segments; // 0 to 1
                const nextT = (i + 1) / segments;
                
                // Calculate year for this segment (interpolate from conception to birth)
                const segmentBottomYear = conceptionDecimal + (birthDecimal - conceptionDecimal) * t;
                const segmentTopYear = conceptionDecimal + (birthDecimal - conceptionDecimal) * nextT;
                
                // Create tapered segment geometry
                const segmentGeom = createTaperedPersonGeometry(
                    mother.userData.x || mother.position.x,
                    mother.userData.z || mother.position.z,
                    segmentBottomYear,
                    segmentTopYear,
                    sex,
                    segmentHeight
                );
                
                // Scale by growth factor (grows from point to full size)
                segmentGeom.scale(nextT, 1, nextT);
                
                const segmentPerspective = applyPerspective(
                    mother.userData.x || mother.position.x, 
                    mother.userData.z || mother.position.z, 
                    segmentBottomYear
                );
                
                const segmentMaterial = new THREE.MeshPhongMaterial({
                    color: childColor,
                    transparent: true,
                    opacity: 0.5,
                    shininess: 20,
                    depthWrite: false
                });
                
                const segment = new THREE.Mesh(segmentGeom, segmentMaterial);
                segment.renderOrder = 10; // Render on top of mother's mesh
                
                const segmentBottomPerspective = applyPerspective(
                    mother.userData.x || mother.position.x, 
                    mother.userData.z || mother.position.z, 
                    segmentBottomYear
                );
                const segmentTopPerspective = applyPerspective(
                    mother.userData.x || mother.position.x, 
                    mother.userData.z || mother.position.z, 
                    segmentTopYear
                );
                
                const segmentCenterY = conceptionHeight + i * segmentHeight + segmentHeight / 2;
                const segmentCenterPos = new THREE.Vector3(
                    (segmentBottomPerspective.x + segmentTopPerspective.x) / 2,
                    segmentCenterY,
                    (segmentBottomPerspective.z + segmentTopPerspective.z) / 2
                );
                
                // Calculate tilt toward origin (same as person stacks)
                const originHeight = (ORIGIN_YEAR - OLDEST_YEAR) * YEAR_SCALE;
                const horizontalDist = Math.sqrt(
                    (segmentCenterPos.x - VANISHING_POINT.x) ** 2 + 
                    (segmentCenterPos.z - VANISHING_POINT.z) ** 2
                );
                const verticalDist = Math.abs(originHeight - segmentCenterY);
                const tiltAmount = perspectiveEnabled ? Math.atan2(horizontalDist, verticalDist) : 0;
                const tiltFactor = 0.6;
                
                const xTilt = tiltAmount * tiltFactor * (segmentCenterPos.z - VANISHING_POINT.z) / (horizontalDist + 0.1);
                const zTilt = -tiltAmount * tiltFactor * (segmentCenterPos.x - VANISHING_POINT.x) / (horizontalDist + 0.1);
                
                segment.position.copy(segmentCenterPos);
                segment.rotation.x = xTilt;
                segment.rotation.z = zTilt;
                
                // Store detailed gestation info for click interaction
                const weekStart = Math.floor((i / segments) * 40);
                const weekEnd = Math.floor((nextT) * 40);
                const trimester = weekStart < 13 ? 1 : weekStart < 27 ? 2 : 3;
                
                segment.userData = { 
                    isGestation: true, 
                    childId: data.id,
                    motherId: motherId,
                    childName: data.name,
                    motherName: mother.userData.name,
                    weekStart: weekStart,
                    weekEnd: weekEnd,
                    trimester: trimester,
                    gestationSegment: i
                };
                conceptionLines.push(segment);
                scene.add(segment);
            }
            
            // Add birth transition line from mother position to child's birth position
            const childData = personMeshes.get(data.id);
            const childBirthPos = applyPerspective(data.x, data.z, birthDecimal);
            const motherBirthPos = applyPerspective(
                mother.userData.x || mother.position.x,
                mother.userData.z || mother.position.z,
                birthDecimal
            );
            
            const birthTransitionPoints = [
                new THREE.Vector3(motherBirthPos.x, birthHeight, motherBirthPos.z),
                new THREE.Vector3(childBirthPos.x, birthHeight, childBirthPos.z)
            ];
            
            const birthLineGeometry = new THREE.BufferGeometry().setFromPoints(birthTransitionPoints);
            const birthLineMaterial = new THREE.LineBasicMaterial({
                color: 0x00ffaa,
                transparent: true,
                opacity: 0.6,
                linewidth: 2
            });
            
            const birthLine = new THREE.Line(birthLineGeometry, birthLineMaterial);
            birthLine.userData = { isBirthTransition: true, childId: data.id };
            conceptionLines.push(birthLine);
            scene.add(birthLine);
            
            // Add arrow showing child "coming out" from mother to independent position
            addArrow(
                new THREE.Vector3(motherBirthPos.x, birthHeight, motherBirthPos.z),
                new THREE.Vector3(childBirthPos.x, birthHeight, childBirthPos.z),
                0x00ffaa
            );
            
            // Add "birth event" marker at mother's position
            const birthMarkerGeometry = new THREE.SphereGeometry(0.15, 16, 16);
            const birthMarkerMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ffaa,
                transparent: true,
                opacity: 0.8
            });
            
            const birthMarker = new THREE.Mesh(birthMarkerGeometry, birthMarkerMaterial);
            birthMarker.position.set(motherBirthPos.x, birthHeight, motherBirthPos.z);
            birthMarker.userData = { isBirthMarker: true, childId: data.id };
            conceptionLines.push(birthMarker);
            scene.add(birthMarker);
        }

        function addNameLabel(text, x, y, z) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 64;
            context.fillStyle = '#ffffff';
            context.font = 'Bold 32px Arial';
            context.textAlign = 'center';
            context.fillText(text, 128, 40);

            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.set(x, y, z);
            sprite.scale.set(1.5, 0.375, 1);
            sprite.userData = { isNameLabel: true, labelText: text };
            scene.add(sprite);
        }

        function createConceptionBar(fatherId, motherId, childId) {
            const father = personMeshes.get(fatherId);
            const mother = personMeshes.get(motherId);
            const child = personMeshes.get(childId);

            if (!father || !mother || !child) {
                console.error('Missing person for conception bar');
                return;
            }

            // Use CONCEPTION height (9 months before birth) not birth height
            const conceptionHeight = child.userData.conceptionHeight;
            const childBirthYear = child.userData.birthYear;
            const conceptionYear = childBirthYear - 0.75; // 9 months before birth
            
            // Get perspective positions at conception time
            const fatherConceptionPos = applyPerspective(
                father.userData.x || father.position.x,
                father.userData.z || father.position.z,
                conceptionYear
            );
            const motherConceptionPos = applyPerspective(
                mother.userData.x || mother.position.x,
                mother.userData.z || mother.position.z,
                conceptionYear
            );

            // Create points for the connection at conception time (when sperm fertilizes egg)
            const points = [];
            
            // Father's GERMLINE position at conception time (sperm comes from germline)
            points.push(new THREE.Vector3(fatherConceptionPos.x, conceptionHeight, fatherConceptionPos.z));

            // Mother's GERMLINE position at conception time (egg comes from germline, fertilized egg starts here)
            points.push(new THREE.Vector3(motherConceptionPos.x, conceptionHeight, motherConceptionPos.z));

            // NOTE: We don't connect to child's position here because at conception,
            // the child is just a point inside the mother

            // Create the line geometry (just father to mother at conception)
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({ 
                color: 0xffff00,
                linewidth: 3,
                transparent: true,
                opacity: 0.8
            });

            const line = new THREE.Line(geometry, material);
            scene.add(line);
            
            // Store line with family info
            line.userData = { fatherId, motherId, childId };
            conceptionLines.push(line);

            // Add arrow pointing from father to mother at conception to show direction of inheritance
            addArrow(new THREE.Vector3(fatherConceptionPos.x, conceptionHeight, fatherConceptionPos.z), 
                     new THREE.Vector3(motherConceptionPos.x, conceptionHeight, motherConceptionPos.z), 0xffff00);

            // Add small spheres at connection points
            const sphereGeometry = new THREE.SphereGeometry(0.1, 16, 16);
            const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            
            points.forEach(point => {
                const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                sphere.position.copy(point);
                sphere.userData = { fatherId, motherId, childId };
                conceptionLines.push(sphere);
                scene.add(sphere);
            });
        }

        function addArrow(from, to, color) {
            // Calculate direction and distance
            const direction = new THREE.Vector3().subVectors(to, from);
            const distance = direction.length();
            direction.normalize();
            
            // Position arrow 70% of the way from parent to child
            const arrowPosition = from.clone().add(direction.clone().multiplyScalar(distance * 0.7));
            
            // Create arrow using cone geometry
            const arrowLength = 0.3;
            const arrowRadius = 0.15;
            const arrowGeometry = new THREE.ConeGeometry(arrowRadius, arrowLength, 8);
            const arrowMaterial = new THREE.MeshBasicMaterial({ 
                color: color,
                transparent: true,
                opacity: 0.8
            });
            const arrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
            
            // Position and orient the arrow
            arrow.position.copy(arrowPosition);
            
            // Point the arrow in the direction from parent to child
            const axis = new THREE.Vector3(0, 1, 0);
            const quaternion = new THREE.Quaternion();
            quaternion.setFromUnitVectors(axis, direction);
            arrow.quaternion.copy(quaternion);
            
            // Store for opacity control
            arrow.userData = { isArrow: true };
            conceptionLines.push(arrow);
            
            scene.add(arrow);
        }

        // Data loaded from API
        let familyData = [];
        let conceptions = [];
        let families = [];
        let lifeEvents = [];

        // API configuration
        const API_BASE_URL = 'https://momi-production.up.railway.app/api';

        // Default sample pedigree data (matching sample_pedigree.ped)
        const SAMPLE_PEDIGREE = `# FamilyID	IndivID	FatherID	MotherID	Sex	Name
# Paternal grandparents
DEMO	PGF	0	0	1	Grandpa Erik
DEMO	PGM	0	0	2	Grandma Anna
# Maternal grandparents
DEMO	MGF	0	0	1	Grandpa Lars
DEMO	MGM	0	0	2	Grandma Karin
# Parents
DEMO	FATHER	PGF	PGM	1	Father Johan
DEMO	MOTHER	MGF	MGM	2	Mother Maria
# Children
DEMO	SON	FATHER	MOTHER	1	Son Anders
DEMO	DAUGHTER	FATHER	MOTHER	2	Daughter Elsa`;

        // Load default sample pedigree
        async function loadDataFromAPI() {
            try {
                document.getElementById('loading').innerHTML = 'Loading sample pedigree...';
                
                // Parse the sample pedigree directly
                return loadSamplePedigree();
            } catch (error) {
                console.error('Error loading sample pedigree:', error);
                document.getElementById('loading').innerHTML = 
                    'Error loading pedigree: ' + error.message;
                document.getElementById('loading').style.background = 'rgba(255, 100, 0, 0.8)';
                return false;
            }
        }
        
        // Parse and load the built-in sample pedigree
        function loadSamplePedigree() {
            const lines = SAMPLE_PEDIGREE.trim().split('\n');
            
            // Clear existing data
            familyData = [];
            conceptions = [];
            families = [];
            lifeEvents = [];
            familyMembers = {};
            
            const newPersons = [];
            const familySet = new Set();
            
            lines.forEach((line) => {
                const trimmedLine = line.trim();
                
                // Skip empty lines and comments
                if (!trimmedLine || trimmedLine.startsWith('#')) return;
                
                const parts = trimmedLine.split(/\t|\s+/);
                if (parts.length < 6) return;
                
                const [familyId, indivId, fatherId, motherId, sex, ...nameParts] = parts;
                
                let name = nameParts.join(' ') || indivId;
                
                familySet.add(familyId);
                
                const person = {
                    id: indivId,
                    name: name,
                    sex: sex === '1' ? 'M' : 'F',
                    birthYear: null,
                    birthMonth: 6,
                    deathYear: null,
                    motherId: motherId === '0' ? null : motherId,
                    fatherId: fatherId === '0' ? null : fatherId,
                    familyId: familyId,
                    x: 0,
                    z: 0
                };
                
                newPersons.push(person);
            });
            
            // Build family members map
            familySet.forEach(fam => {
                familyMembers[fam] = newPersons.filter(p => p.familyId === fam).map(p => p.id);
            });
            
            // Assign default birth years based on generation
            assignDefaultBirthYears(newPersons);
            
            // Auto-calculate positions
            assignPositions(newPersons);
            
            // Build conceptions array
            newPersons.forEach(person => {
                if (person.motherId && person.fatherId) {
                    conceptions.push({
                        father: person.fatherId,
                        mother: person.motherId,
                        child: person.id
                    });
                }
            });
            
            // Update global data
            familyData = newPersons;
            
            families = Array.from(familySet).map(fam => ({
                id: fam,
                name: fam,
                members: familyMembers[fam]
            }));
            
            console.log(`Loaded sample pedigree with ${familyData.length} persons`);
            return true;
        }

        function createFamily() {
            // Populate familyMembers from loaded families data
            families.forEach(family => {
                familyMembers[family.id] = family.members;
            });
            
            // Add evolutionary perspective guide only when perspective is enabled
            if (perspectiveEnabled) {
                addEvolutionaryPerspectiveGuide();
            }

            // Create all people
            familyData.forEach(person => createPerson(person));

            // Create conception bars
            conceptions.forEach(conception => {
                createConceptionBar(conception.father, conception.mother, conception.child);
            });
        }
        
        // Add visual guide showing convergence toward origin point
        function addEvolutionaryPerspectiveGuide() {
            const originHeight = (ORIGIN_YEAR - OLDEST_YEAR) * YEAR_SCALE;
            const presentHeight = (CURRENT_YEAR - OLDEST_YEAR) * YEAR_SCALE;
            
            // ELEVATION CONTOURS - Rings showing climbing progress up the mountain
            const totalHeight = presentHeight - originHeight;
            const numContours = 8;
            
            for (let i = 1; i <= numContours; i++) {
                const progress = i / numContours;
                const contourHeight = originHeight + (totalHeight * progress);
                const contourYear = ORIGIN_YEAR + ((CURRENT_YEAR - ORIGIN_YEAR) * progress);
                
                // Rings get smaller as we climb (mountain gets narrower)
                const baseRadius = 15 * (1 - progress * 0.6);
                
                // Create contour as a line that follows perspective
                const segments = 64;
                const contourPoints = [];
                
                for (let j = 0; j <= segments; j++) {
                    const angle = (j / segments) * Math.PI * 2;
                    const x = Math.cos(angle) * baseRadius;
                    const z = Math.sin(angle) * baseRadius;
                    
                    // Apply perspective transformation to each point
                    const perspectivePos = applyPerspective(x, z, contourYear);
                    contourPoints.push(new THREE.Vector3(perspectivePos.x, contourHeight, perspectivePos.z));
                }
                
                const contourGeometry = new THREE.BufferGeometry().setFromPoints(contourPoints);
                const contourMaterial = new THREE.LineBasicMaterial({
                    color: 0x6a8a9a,
                    transparent: true,
                    opacity: 0.3 + (progress * 0.2)
                });
                const contourLine = new THREE.Line(contourGeometry, contourMaterial);
                contourLine.userData = { isPerspectiveGuide: true };
                scene.add(contourLine);
                
                // Add elevation markers
                if (i % 2 === 0) {
                    const markerAngle = Math.PI / 4;
                    const markerX = Math.cos(markerAngle) * baseRadius;
                    const markerZ = Math.sin(markerAngle) * baseRadius;
                    const markerPos = applyPerspective(markerX, markerZ, contourYear);
                    
                    const markerCanvas = document.createElement('canvas');
                    markerCanvas.width = 256;
                    markerCanvas.height = 64;
                    const ctx = markerCanvas.getContext('2d');
                    ctx.fillStyle = '#8aaaaa';
                    ctx.font = 'bold 24px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(`Elevation: ${Math.round(progress * 100)}%`, 128, 40);
                    
                    const markerTexture = new THREE.CanvasTexture(markerCanvas);
                    const markerMaterial = new THREE.SpriteMaterial({ 
                        map: markerTexture,
                        transparent: true,
                        opacity: 0.6
                    });
                    const marker = new THREE.Sprite(markerMaterial);
                    marker.position.set(markerPos.x, contourHeight, markerPos.z);
                    marker.scale.set(3, 0.75, 1);
                    marker.userData = { isPerspectiveGuide: true };
                    scene.add(marker);
                }
            }
            
            // Original perspective guide elements (converging lines)
            const guidePositions = [
                { x: -10, z: -10 },
                { x: -10, z: 10 },
                { x: 10, z: -10 },
                { x: 10, z: 10 },
                { x: 0, z: -15 },
                { x: 0, z: 15 },
                { x: -15, z: 0 },
                { x: 15, z: 0 }
            ];
            
            const lineColor = 0x3a5a7a;
            const lineMaterial = new THREE.LineBasicMaterial({ 
                color: lineColor,
                transparent: true,
                opacity: 0.15
            });
            
            guidePositions.forEach(pos => {
                // Line from present position down to origin point
                const presentPos = applyPerspective(pos.x, pos.z, CURRENT_YEAR);
                const originPos = applyPerspective(pos.x, pos.z, ORIGIN_YEAR);
                
                const points = [
                    new THREE.Vector3(presentPos.x, presentHeight, presentPos.z),
                    new THREE.Vector3(originPos.x, originHeight, originPos.z)
                ];
                
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const line = new THREE.Line(geometry, lineMaterial);
                line.userData = { isPerspectiveGuide: true };
                scene.add(line);
            });
            
            // Add a prominent marker at the origin point (small because it's far away)
            const originGeometry = new THREE.SphereGeometry(0.3, 32, 32);
            const originMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xffaa00,
                emissive: 0xffaa00,
                emissiveIntensity: 1.2,
                transparent: true,
                opacity: 1.0
            });
            const originMarker = new THREE.Mesh(originGeometry, originMaterial);
            originMarker.position.set(VANISHING_POINT.x, originHeight, VANISHING_POINT.z);
            originMarker.userData = { isPerspectiveGuide: true };
            scene.add(originMarker);
            
            // Add pulsing point light at origin (small but intense)
            const originLight = new THREE.PointLight(0xffaa00, 3, 8);
            originLight.position.set(VANISHING_POINT.x, originHeight, VANISHING_POINT.z);
            originLight.userData = { isPerspectiveGuide: true };
            scene.add(originLight);
            
            // Animate the light to pulse (more dramatic for distant point)
            const originLightData = { light: originLight, phase: 0 };
            function animateOriginLight() {
                originLightData.phase += 0.08;
                originLightData.light.intensity = 2 + Math.sin(originLightData.phase) * 1.5;
                requestAnimationFrame(animateOriginLight);
            }
            animateOriginLight();
            
            // Add a subtle grid at the origin level
            const gridSize = 30;
            const gridDivisions = 15;
            const gridHelper = new THREE.GridHelper(gridSize, gridDivisions, 0x4a6a8a, 0x3a5a7a);
            gridHelper.position.y = originHeight - 0.1;
            gridHelper.material.transparent = true;
            gridHelper.material.opacity = 0.1;
            gridHelper.userData = { isPerspectiveGuide: true };
            scene.add(gridHelper);
            
            // Add clear text label for origin point
            const originLabelGeometry = new THREE.PlaneGeometry(8, 1.2);
            const canvas = document.createElement('canvas');
            canvas.width = 1024;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            
            // Add glow effect
            ctx.shadowColor = '#ffaa00';
            ctx.shadowBlur = 20;
            ctx.fillStyle = '#ffdd66';
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('‚ö° ORIGIN OF LIFE ‚ö°', 512, 70);
            
            // Add year subtitle
            ctx.shadowBlur = 10;
            ctx.font = '32px Arial';
            ctx.fillStyle = '#ffbb44';
            ctx.fillText(`(${ORIGIN_YEAR})`, 512, 105);
            
            const texture = new THREE.CanvasTexture(canvas);
            const labelMaterial = new THREE.MeshBasicMaterial({ 
                map: texture, 
                transparent: true,
                opacity: 0.9,
                side: THREE.DoubleSide
            });
            const label = new THREE.Mesh(originLabelGeometry, labelMaterial);
            label.position.set(0, originHeight - 1.5, 0);
            label.rotation.x = -Math.PI / 2;
            label.userData = { isPerspectiveGuide: true };
            scene.add(label);
        }

        function onMouseClick(event) {
            const container = document.getElementById('canvas-container');
            const rect = container.getBoundingClientRect();
            
            const mouse = new THREE.Vector2();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);

            // Check for genome visualizations first
            const allObjects = scene.children;
            const genomeIntersects = raycaster.intersectObjects(
                allObjects.filter(obj => obj.userData.isGenome),
                true // Check children
            );
            
            if (genomeIntersects.length > 0) {
                const genomeGroup = genomeIntersects[0].object.parent;
                if (genomeGroup && genomeGroup.userData.genomeData) {
                    openGenomeBrowser(genomeGroup.userData.genomeData);
                    return;
                }
            }

            // Check for life event markers
            const lifeEventIntersects = raycaster.intersectObjects(allObjects.filter(obj => obj.userData.isLifeEvent));
            
            if (lifeEventIntersects.length > 0) {
                const eventMarker = lifeEventIntersects[0].object;
                const eventData = eventMarker.userData.event;
                
                alert(`Life Event: ${eventData.name}\\nYear: ${eventData.onsetYear}\\nSeverity: ${eventData.severity}\\nDescription: ${eventData.description}`);
                return;
            }
            
            // Check for gestation segments
            const gestationIntersects = raycaster.intersectObjects(allObjects.filter(obj => obj.userData.isGestation));
            
            if (gestationIntersects.length > 0) {
                const gestationSegment = gestationIntersects[0].object;
                const data = gestationSegment.userData;
                
                console.log('Clicked gestation segment:', data);
                
                // Open birth view in new window
                const childMesh = personMeshes.get(data.childId);
                const motherMesh = personMeshes.get(data.motherId);
                
                if (childMesh && motherMesh) {
                    const childData = childMesh.userData;
                    const params = new URLSearchParams({
                        childId: data.childId,
                        childName: data.childName,
                        motherName: data.motherName,
                        birthYear: childData.birthYear,
                        birthMonth: childData.birthMonth || 6,
                        sex: childData.sex,
                        conceptionYear: childData.conceptionHeight / YEAR_SCALE
                    });
                    
                    const url = `birth_view.html?${params.toString()}`;
                    console.log('Opening:', url);
                    
                    // Try to open in new tab - user may need to allow popups
                    const newWindow = window.open(url, '_blank');
                    
                    if (!newWindow) {
                        // Popup blocked - show message
                        alert('Please allow popups for this site to view the birth journey.\n\nOr right-click on a gestation segment and select "Open in new tab".');
                    }
                } else {
                    console.error('Could not find child or mother mesh:', data.childId, data.motherId);
                }
                
                return;
            }
            
            // Then check for person meshes
            const meshes = Array.from(personMeshes.values());
            const intersects = raycaster.intersectObjects(meshes);

            if (intersects.length > 0) {
                const clickedMesh = intersects[0].object;
                selectPerson(clickedMesh);
            } else {
                deselectPerson();
            }
        }

        function selectPerson(mesh) {
            // Deselect previous
            if (selectedPerson) {
                selectedPerson.material.emissive.setHex(
                    selectedPerson.userData.sex === 'F' ? 0xff1493 : 0x000000
                );
                selectedPerson.material.emissiveIntensity = selectedPerson.userData.sex === 'F' ? 0.1 : 0;
            }

            // Select new
            selectedPerson = mesh;
            mesh.material.emissive.setHex(0xffff00);
            mesh.material.emissiveIntensity = 0.3;

            // Display info
            displayPersonInfo(mesh.userData);
        }

        function deselectPerson() {
            if (selectedPerson) {
                selectedPerson.material.emissive.setHex(
                    selectedPerson.userData.sex === 'F' ? 0xff1493 : 0x000000
                );
                selectedPerson.material.emissiveIntensity = selectedPerson.userData.sex === 'F' ? 0.1 : 0;
                selectedPerson = null;
            }
            document.getElementById('person-details').innerHTML = '';
        }
        
        function selectFamily(family) {
            selectedFamily = family;
            
            // Update all person meshes
            personMeshes.forEach((mesh, id) => {
                const isSmith = familyMembers.smith.includes(id);
                const isChen = familyMembers.chen.includes(id);
                const isDeceased = mesh.userData.deathYear !== null && mesh.userData.deathYear !== undefined;
                
                if (family === null) {
                    // Show all - restore colors based on living status
                    if (isDeceased) {
                        mesh.material.color.setHex(0x888888);
                        mesh.material.opacity = 0.6;
                    } else {
                        mesh.material.color.setHex(mesh.userData.sex === 'F' ? 0xff69b4 : 0x4169e1);
                        mesh.material.opacity = 0.9;
                    }
                } else if ((family === 'smith' && isSmith) || (family === 'chen' && isChen)) {
                    // Selected family - show colors based on living status
                    if (isDeceased) {
                        mesh.material.color.setHex(0x888888);
                        mesh.material.opacity = 0.6;
                    } else {
                        mesh.material.color.setHex(mesh.userData.sex === 'F' ? 0xff69b4 : 0x4169e1);
                        mesh.material.opacity = 0.9;
                    }
                } else {
                    // Non-selected family - grey and transparent
                    mesh.material.opacity = 0.3;
                    mesh.material.color.setHex(0x666666);
                }
            });
            
            // Update conception lines
            conceptionLines.forEach(obj => {
                const childId = obj.userData.childId;
                const isSmith = familyMembers.smith.includes(childId);
                const isChen = familyMembers.chen.includes(childId);
                
                if (family === null) {
                    obj.material.opacity = 0.8;
                } else if ((family === 'smith' && isSmith) || (family === 'chen' && isChen)) {
                    obj.material.opacity = 0.8;
                } else {
                    obj.material.opacity = 0.2;
                }
            });
            
            // Display family info
            displayFamilyInfo(family);
        }
        
        function displayFamilyInfo(family) {
            const infoDiv = document.getElementById('family-info');
            
            if (family === null) {
                infoDiv.innerHTML = '';
                return;
            }
            
            const familyData = {
                smith: {
                    name: 'Smith Family',
                    members: 9,
                    generations: 3,
                    oldest: 'Robert (1938)',
                    youngest: 'Sarah (1999)',
                    living: 6
                },
                chen: {
                    name: 'Chen Family',
                    members: 8,
                    generations: 3,
                    oldest: 'Tao (1943)',
                    youngest: 'Maya (2003)',
                    living: 6
                }
            };
            
            const info = familyData[family];
            const html = `
                <div class="person-info" style="background: #e3f2fd;">
                    <h3>${info.name}</h3>
                    <p><strong>Total Members:</strong> ${info.members}</p>
                    <p><strong>Generations:</strong> ${info.generations}</p>
                    <p><strong>Oldest:</strong> ${info.oldest}</p>
                    <p><strong>Youngest:</strong> ${info.youngest}</p>
                    <p><strong>Living:</strong> ${info.living}</p>
                </div>
            `;
            
            infoDiv.innerHTML = html;
        }

        function displayPersonInfo(data) {
            const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            const birthDecimal = data.birthYear + ((data.birthMonth || 6) - 1) / 12;
            const age = data.deathYear ? 
                (data.deathYear - birthDecimal) : 
                (CURRENT_YEAR + 11/12 - birthDecimal);
            
            const status = data.deathYear ? `Deceased (${data.deathYear})` : 'Living';
            const birthDate = data.birthMonth ? 
                `${monthNames[data.birthMonth - 1]} ${data.birthYear}` : 
                data.birthYear;
            
            // Get life events for this person
            const personEvents = lifeEvents.filter(event => event.personId === data.id);
            let eventsHtml = '';
            if (personEvents.length > 0) {
                eventsHtml = '<p><strong>Life Events:</strong></p><ul style="margin: 5px 0; padding-left: 20px;">';
                personEvents.forEach(event => {
                    const severityColor = {
                        'severe': '#ff0000',
                        'moderate': '#ff9900',
                        'mild': '#ffff00',
                        'positive': '#00ff00'
                    }[event.severity] || '#ffffff';
                    eventsHtml += `<li style="color: ${severityColor}; margin: 3px 0;">
                        <strong>${event.name}</strong> (${event.onsetYear})<br/>
                        <span style="color: #666; font-size: 11px;">${event.description}</span>
                    </li>`;
                });
                eventsHtml += '</ul>';
            }
            
            const html = `
                <div class="person-info">
                    <h3>${data.name}</h3>
                    <p><strong>Sex:</strong> ${data.sex === 'M' ? 'Male' : 'Female'}</p>
                    <p><strong>Birth:</strong> ${birthDate}</p>
                    <p><strong>Age:</strong> ${age.toFixed(1)} years</p>
                    <p><strong>Status:</strong> ${status}</p>
                    <p><strong>Position:</strong> (${data.x.toFixed(1)}, ${data.z.toFixed(1)})</p>
                    ${eventsHtml}
                </div>
            `;
            
            document.getElementById('person-details').innerHTML = html;
        }
        
        function displayGestationInfo(gestationData) {
            const { childName, motherName, weekStart, weekEnd, trimester, gestationSegment } = gestationData;
            
            const trimesterInfo = {
                1: { name: 'First Trimester', desc: 'Embryonic development, organ formation', weeks: '0-13' },
                2: { name: 'Second Trimester', desc: 'Rapid growth, movement begins', weeks: '14-26' },
                3: { name: 'Third Trimester', desc: 'Final development, preparing for birth', weeks: '27-40' }
            };
            
            const info = trimesterInfo[trimester];
            
            const html = `
                <div class="person-info" style="background: #e8f5e9;">
                    <h3>Gestation Period</h3>
                    <p><strong>Child:</strong> ${childName}</p>
                    <p><strong>Mother:</strong> ${motherName}</p>
                    <p><strong>Weeks:</strong> ${weekStart}-${weekEnd} of 40</p>
                    <p><strong>${info.name}</strong></p>
                    <p><em>${info.desc}</em></p>
                    <p style="font-size: 11px; color: #666; margin-top: 8px;">
                        ${info.weeks} weeks total
                    </p>
                </div>
            `;
            
            document.getElementById('person-details').innerHTML = html;
            
            // Create focused birth visualization
            createBirthFocusView(gestationData);
        }
        
        function createBirthFocusView(gestationData) {
            // Clear any existing focus view
            scene.children.filter(obj => obj.userData.isFocusView).forEach(obj => scene.remove(obj));
            
            const { childId, motherId, childName, motherName } = gestationData;
            
            // Get child and mother data
            const childMesh = personMeshes.get(childId);
            const motherMesh = personMeshes.get(motherId);
            
            if (!childMesh || !motherMesh) return;
            
            const childData = childMesh.userData;
            const motherData = motherMesh.userData;
            
            // Calculate timeline positions for focused view
            const conceptionHeight = childData.conceptionHeight;
            const birthHeight = childData.birthHeight;
            const gestationDuration = birthHeight - conceptionHeight; // 9 months
            const postBirthDuration = gestationDuration * 0.5; // Show 4.5 months after birth
            
            // Position focused view to the right of main scene
            const focusX = 20;
            const focusZ = 0;
            const timelineStart = conceptionHeight;
            
            // Create mother's stack (partial, just during gestation)
            const motherStackHeight = gestationDuration * 1.2; // Extend a bit beyond gestation
            const motherStackGeometry = new THREE.BoxGeometry(
                PERSON_WIDTH * 1.5,
                motherStackHeight,
                PERSON_DEPTH * 1.5
            );
            const motherStackMaterial = new THREE.MeshPhongMaterial({
                color: 0xff69b4,
                transparent: true,
                opacity: 0.3,
                wireframe: false
            });
            const motherStack = new THREE.Mesh(motherStackGeometry, motherStackMaterial);
            motherStack.position.set(focusX, conceptionHeight + motherStackHeight / 2, focusZ);
            motherStack.userData.isFocusView = true;
            scene.add(motherStack);
            
            // Create growing child inside mother (tapered from point to full size)
            const segments = 10;
            const segmentHeight = gestationDuration / segments;
            const childColor = childData.sex === 'F' ? 0xff69b4 : 0x4169e1;
            
            for (let i = 0; i < segments; i++) {
                const t = i / segments;
                const nextT = (i + 1) / segments;
                
                const widthTop = PERSON_WIDTH * nextT;
                const depthTop = PERSON_DEPTH * nextT;
                
                const shape = new THREE.Shape();
                const hw = widthTop / 2;
                const hd = depthTop / 2;
                
                // Rectangle for simplicity in focus view
                shape.moveTo(-hw, -hd);
                shape.lineTo(hw, -hd);
                shape.lineTo(hw, hd);
                shape.lineTo(-hw, hd);
                
                const extrudeSettings = {
                    depth: segmentHeight,
                    bevelEnabled: false,
                    steps: 1
                };
                
                const segmentGeometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
                segmentGeometry.rotateX(Math.PI / 2);
                
                const segmentMaterial = new THREE.MeshPhongMaterial({
                    color: childColor,
                    transparent: true,
                    opacity: 0.7,
                    shininess: 30
                });
                
                const segment = new THREE.Mesh(segmentGeometry, segmentMaterial);
                segment.position.set(
                    focusX,
                    conceptionHeight + i * segmentHeight + segmentHeight / 2,
                    focusZ
                );
                segment.userData.isFocusView = true;
                scene.add(segment);
            }
            
            // Add birth transition marker
            const birthMarkerGeometry = new THREE.SphereGeometry(0.3, 16, 16);
            const birthMarkerMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ffaa,
                emissive: 0x00ffaa,
                emissiveIntensity: 0.5
            });
            const birthMarker = new THREE.Mesh(birthMarkerGeometry, birthMarkerMaterial);
            birthMarker.position.set(focusX, birthHeight, focusZ);
            birthMarker.userData.isFocusView = true;
            scene.add(birthMarker);
            
            // Create child's independent stack (post-birth)
            const postBirthStackGeometry = new THREE.BoxGeometry(
                PERSON_WIDTH,
                postBirthDuration,
                PERSON_DEPTH
            );
            const postBirthStackMaterial = new THREE.MeshPhongMaterial({
                color: childColor,
                transparent: true,
                opacity: 0.8,
                shininess: 30
            });
            const postBirthStack = new THREE.Mesh(postBirthStackGeometry, postBirthStackMaterial);
            postBirthStack.position.set(
                focusX + 2, // Offset to the right to show separation
                birthHeight + postBirthDuration / 2,
                focusZ
            );
            postBirthStack.userData.isFocusView = true;
            scene.add(postBirthStack);
            
            // Add arrow showing birth transition
            const birthArrowPoints = [
                new THREE.Vector3(focusX, birthHeight, focusZ),
                new THREE.Vector3(focusX + 2, birthHeight, focusZ)
            ];
            const birthArrowGeometry = new THREE.BufferGeometry().setFromPoints(birthArrowPoints);
            const birthArrowMaterial = new THREE.LineBasicMaterial({
                color: 0x00ffaa,
                linewidth: 3
            });
            const birthArrow = new THREE.Line(birthArrowGeometry, birthArrowMaterial);
            birthArrow.userData.isFocusView = true;
            scene.add(birthArrow);
            
            // Add text labels
            addFocusLabel('CONCEPTION', focusX, conceptionHeight - 0.5, focusZ);
            addFocusLabel('BIRTH', focusX + 1, birthHeight + 0.5, focusZ);
            addFocusLabel(`${childName}'s Journey`, focusX, birthHeight + postBirthDuration + 1, focusZ);
            
            // Zoom camera to focus view
            camera.position.set(focusX + 8, birthHeight, focusZ + 8);
            controls.target.set(focusX, birthHeight, focusZ);
            controls.update();
        }
        
        function addFocusLabel(text, x, y, z) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 64;
            context.fillStyle = '#ffffff';
            context.font = 'Bold 32px Arial';
            context.textAlign = 'center';
            context.fillText(text, 128, 40);
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.set(x, y, z);
            sprite.scale.set(2, 0.5, 1);
            sprite.userData.isFocusView = true;
            scene.add(sprite);
        }

        function resetCamera() {
            camera.position.set(15, 10, 15);
            camera.lookAt(0, 0, 0);
            controls.target.set(0, 0, 0);
            controls.update();
        }
        
        function togglePerspective() {
            // Toggle the perspective state
            perspectiveEnabled = !perspectiveEnabled;
            
            // Update button text
            const button = document.getElementById('toggle-perspective');
            button.textContent = perspectiveEnabled ? 'Disable Perspective' : 'Enable Perspective';
            button.style.background = perspectiveEnabled ? '#ff6b35' : '#4CAF50';
            
            // Clear the scene (keep camera, lights, and controls)
            while(scene.children.length > 0) { 
                scene.remove(scene.children[0]); 
            }
            
            // Re-add lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // Re-add scene elements
            addPresentGrid();
            const axesHelper = new THREE.AxesHelper(5);
            if (perspectiveEnabled) {
                const originHeight = (ORIGIN_YEAR - OLDEST_YEAR) * YEAR_SCALE;
                axesHelper.position.set(VANISHING_POINT.x, originHeight, VANISHING_POINT.z);
            }
            scene.add(axesHelper);
            addAxisLabels();
            addTimeAxis();
            
            // Clear stored data
            personMeshes.clear();
            conceptionLines.length = 0;
            lifeEventMarkers.length = 0;
            genomeVisualizations.length = 0;
            cellTypeVisualizations.length = 0;
            if (genomeLegend) {
                scene.remove(genomeLegend);
                genomeLegend = null;
            }
            
            // Recreate everything
            createFamily();
            
            // Add genome legend if genomes are visible
            if (genomesVisible) {
                createGenomeLegend();
            }
        }
        
        // Open genome browser in new window
        function openGenomeBrowser(genomeData) {
            const dataParam = encodeURIComponent(JSON.stringify(genomeData));
            const url = `genome_browser.html?data=${dataParam}`;
            window.open(url, '_blank', 'width=1400,height=900');
        }
        
        function toggleLifeEvents() {
            lifeEventsVisible = !lifeEventsVisible;
            
            // Update button text
            const button = document.getElementById('toggle-life-events');
            button.textContent = lifeEventsVisible ? 'Hide Life Events' : 'Show Life Events';
            button.style.background = lifeEventsVisible ? '#9c27b0' : '#4CAF50';
            
            // Toggle visibility of all life event markers
            lifeEventMarkers.forEach(marker => {
                marker.visible = lifeEventsVisible;
            });
        }
        
        function toggleGenomes() {
            genomesVisible = !genomesVisible;
            console.log('Toggle genomes clicked, genomesVisible is now:', genomesVisible);
            
            // Update button text
            const button = document.getElementById('toggle-genomes');
            button.textContent = genomesVisible ? 'Hide Diploid Genomes' : 'Show Diploid Genomes';
            button.style.background = genomesVisible ? '#2196f3' : '#4CAF50';
            
            // Toggle HTML legend overlay
            const legendOverlay = document.getElementById('genome-legend');
            legendOverlay.style.display = genomesVisible ? 'block' : 'none';
            
            // Toggle visibility of all genome visualizations
            genomeVisualizations.forEach(genome => {
                genome.visible = genomesVisible;
            });
        }
        
        function toggleEnvironment() {
            environmentView = !environmentView;
            
            // Update button text
            const button = document.getElementById('toggle-environment');
            button.textContent = environmentView ? 'Show Individual View' : 'Show Environment View';
            button.style.background = environmentView ? '#8bc34a' : '#4CAF50';
            
            // Update view mode indicator
            const indicator = document.getElementById('view-mode-indicator');
            if (environmentView) {
                indicator.textContent = 'Environment View';
                indicator.style.background = 'rgba(139, 195, 74, 0.9)';
            } else {
                indicator.textContent = 'Individual View';
                indicator.style.background = 'rgba(0, 0, 0, 0.7)';
            }
            
            // Hide genomes and life events in environment view
            if (environmentView) {
                // Hide genome legend
                const legendOverlay = document.getElementById('genome-legend');
                legendOverlay.style.display = 'none';
                
                // Hide genome toggle button
                document.getElementById('toggle-genomes').style.display = 'none';
                document.getElementById('toggle-life-events').style.display = 'none';
                document.getElementById('toggle-cell-types').style.display = 'none';
                
                // Hide all existing life event markers
                lifeEventMarkers.forEach(marker => {
                    marker.visible = false;
                });
            } else {
                // Restore buttons
                document.getElementById('toggle-genomes').style.display = 'block';
                document.getElementById('toggle-life-events').style.display = 'block';
                document.getElementById('toggle-cell-types').style.display = 'block';
                
                // Restore genome legend if genomes were visible
                if (genomesVisible) {
                    const legendOverlay = document.getElementById('genome-legend');
                    legendOverlay.style.display = 'block';
                }
                
                // Restore life event markers if they were visible
                if (lifeEventsVisible) {
                    lifeEventMarkers.forEach(marker => {
                        marker.visible = true;
                    });
                }
            }
            
            // Clear scene and rebuild
            clearScene();
            createFamily();
        }
        
        let tooltip = null;
        function onMouseMove(event) {
            const container = document.getElementById('canvas-container');
            const rect = container.getBoundingClientRect();
            
            const mouse = new THREE.Vector2();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);

            // Create tooltip if it doesn't exist
            if (!tooltip) {
                tooltip = document.createElement('div');
                tooltip.className = 'event-tooltip';
                document.body.appendChild(tooltip);
            }

            // Check for cell type meshes first (if visible)
            if (cellTypesVisible) {
                const cellTypeObjects = [];
                cellTypeVisualizations.forEach(group => {
                    if (group.visible) {
                        group.children.forEach(child => {
                            if (child.userData.isCellType) {
                                cellTypeObjects.push(child);
                            }
                        });
                    }
                });
                
                const cellTypeIntersects = raycaster.intersectObjects(cellTypeObjects);
                
                if (cellTypeIntersects.length > 0) {
                    const cellData = cellTypeIntersects[0].object.userData;
                    
                    // Get person name from personMeshes
                    const personMesh = personMeshes.get(cellData.personId);
                    const personName = personMesh ? personMesh.userData.name : 'Unknown';
                    
                    const isGermline = cellData.isGermline;
                    const borderColor = isGermline ? '#ffaa00' : '#888';
                    const bgColor = isGermline ? 'rgba(255, 170, 0, 0.15)' : 'rgba(0, 0, 0, 0.9)';
                    
                    tooltip.innerHTML = `
                        <div style="border-left: 3px solid ${borderColor}; padding-left: 8px; background: ${bgColor}; margin: -10px -15px; padding: 10px 15px;">
                            <h4 style="color: ${isGermline ? '#ffaa00' : '#fff'}; margin: 0 0 5px 0;">${cellData.cellTypeName}</h4>
                            <p style="margin: 2px 0; font-size: 11px; color: #aaa;">Person: ${personName}</p>
                            ${isGermline ? '<p style="margin: 5px 0 0 0; font-size: 10px; color: #ffcc66; font-style: italic;">Reproductive cells (eggs/sperm)</p>' : ''}
                        </div>
                    `;
                    
                    tooltip.style.left = (event.clientX + 15) + 'px';
                    tooltip.style.top = (event.clientY + 15) + 'px';
                    tooltip.style.display = 'block';
                    tooltip.style.border = isGermline ? '2px solid #ffaa00' : '2px solid #ffaa00';
                    return; // Don't check other objects
                }
            }

            // Check for life event markers
            const visibleMarkers = lifeEventMarkers.filter(m => m.visible && m.userData.isLifeEvent);
            const intersects = raycaster.intersectObjects(visibleMarkers);

            if (intersects.length > 0 && intersects[0].object.userData.isLifeEvent) {
                const eventData = intersects[0].object.userData.event;
                
                const severityColors = {
                    'severe': '#ff0000',
                    'moderate': '#ff9900',
                    'mild': '#ffff00',
                    'positive': '#00ff00'
                };
                
                tooltip.innerHTML = `
                    <h4 style="color: ${severityColors[eventData.severity] || '#ffffff'}">${eventData.name}</h4>
                    <p><strong>Year:</strong> ${eventData.onsetYear}</p>
                    <p><strong>Severity:</strong> ${eventData.severity}</p>
                    <p><strong>Type:</strong> ${eventData.eventType}</p>
                    <p style="margin-top: 5px; font-style: italic;">${eventData.description}</p>
                `;
                
                tooltip.style.left = (event.clientX + 15) + 'px';
                tooltip.style.top = (event.clientY + 15) + 'px';
                tooltip.style.display = 'block';
            } else {
                // Hide tooltip
                tooltip.style.display = 'none';
            }
        }

        // ============ IMPORT/EXPORT FUNCTIONS ============
        
        // Clear pedigree - user-triggered clear
        function clearPedigree() {
            clearScene();
            familyData = [];
            conceptions = [];
            families = [];
            lifeEvents = [];
            familyMembers = {};
            updatePedigreeInfo();
            console.log('Pedigree cleared');
        }
        
        // Clear the current scene of all person meshes and related objects
        function clearScene() {
            // Collect all objects to remove - be aggressive, keep only essential static elements
            const objectsToRemove = [];
            
            // Get the present grid height for identification
            const presentHeight = (CURRENT_YEAR - OLDEST_YEAR) * YEAR_SCALE;
            
            // Time axis base position
            const axisBaseX = -6;
            const axisBaseZ = -6;
            
            scene.traverse(obj => {
                // Skip the root scene
                if (obj === scene) return;
                
                // Skip cameras
                if (obj.isCamera) return;
                
                // Skip ambient and directional lights (main scene lighting)
                if (obj.isAmbientLight || obj.isDirectionalLight) return;
                
                // Skip axes helper (RGB axes at origin)
                if (obj.isAxesHelper) return;
                
                // Skip the present-level grid (green grid at y = presentHeight)
                if (obj.isGridHelper && Math.abs(obj.position.y - presentHeight) < 0.5) return;
                
                // Skip the green "BIOSPHERE, NOW" plane and its edges at present height
                if (obj.isMesh && obj.position && Math.abs(obj.position.y - presentHeight) < 0.5 && 
                    obj.geometry && obj.geometry.type === 'PlaneGeometry') return;
                if (obj.isLineSegments && obj.position && Math.abs(obj.position.y - presentHeight) < 0.5) return;
                
                // Skip time axis elements (white lines and labels near x=-6, z=-6)
                if (obj.isLine && obj.material && obj.material.color) {
                    const color = obj.material.color;
                    // White lines are time axis (color is 0xffffff = r:1, g:1, b:1)
                    if (color.r === 1 && color.g === 1 && color.b === 1) {
                        return; // Keep white axis lines
                    }
                }
                
                // Skip year label sprites (white text sprites near the time axis at x < -5)
                if (obj.isSprite && obj.position) {
                    const pos = obj.position;
                    // Year labels are positioned at x < -5 (near the time axis)
                    if (pos.x < -5) {
                        return; // Keep year labels
                    }
                    // X axis label at (8, 0, 0)
                    if (Math.abs(pos.y) < 0.5 && Math.abs(pos.x - 8) < 1 && Math.abs(pos.z) < 1) {
                        return;
                    }
                    // Z axis label at (0, 0, 8)
                    if (Math.abs(pos.y) < 0.5 && Math.abs(pos.x) < 1 && Math.abs(pos.z - 8) < 1) {
                        return;
                    }
                    // Y/NOW label at top center
                    if (Math.abs(pos.y - presentHeight - 1) < 1.5 && Math.abs(pos.x) < 1 && Math.abs(pos.z) < 1) {
                        return;
                    }
                    // BIOSPHERE NOW label at presentHeight + 0.5
                    if (Math.abs(pos.y - presentHeight - 0.5) < 0.5 && Math.abs(pos.x) < 1 && Math.abs(pos.z) < 1) {
                        return;
                    }
                }
                
                // Remove everything else
                objectsToRemove.push(obj);
            });
            
            // Remove collected objects
            objectsToRemove.forEach(obj => {
                scene.remove(obj);
                if (obj.geometry) obj.geometry.dispose();
                if (obj.material) {
                    if (Array.isArray(obj.material)) {
                        obj.material.forEach(m => m.dispose());
                    } else {
                        obj.material.dispose();
                    }
                }
            });
            
            // Clear tracking arrays and maps
            personMeshes.clear();
            conceptionLines.length = 0;
            lifeEventMarkers.length = 0;
            genomeVisualizations.length = 0;
            cellTypeVisualizations.length = 0;
            
            console.log(`Cleared ${objectsToRemove.length} objects from scene`);
        }
        
        // Update pedigree info display
        function updatePedigreeInfo() {
            const infoDiv = document.getElementById('pedigree-info');
            if (familyData.length === 0) {
                infoDiv.innerHTML = `
                    <strong>No pedigree loaded</strong><br>
                    Import a .ped file to visualize your family tree.
                `;
                return;
            }
            
            const numPersons = familyData.length;
            const males = familyData.filter(p => p.sex === 'M').length;
            const females = familyData.filter(p => p.sex === 'F').length;
            const living = familyData.filter(p => !p.deathYear).length;
            const deceased = familyData.filter(p => p.deathYear).length;
            const eventCount = lifeEvents.length;
            
            // Calculate generations (rough estimate based on parent chains)
            const generations = calculateGenerations();
            
            infoDiv.innerHTML = `
                <strong>Pedigree Loaded</strong><br>
                ‚Ä¢ Individuals: ${numPersons} (${males}‚ôÇ / ${females}‚ôÄ)<br>
                ‚Ä¢ Status: ${living} living, ${deceased} deceased<br>
                ‚Ä¢ Generations: ~${generations}<br>
                ‚Ä¢ Life Events: ${eventCount}
            `;
        }
        
        // Calculate number of generations in the pedigree
        function calculateGenerations() {
            if (familyData.length === 0) return 0;
            
            // Find roots (people with no parents in the data)
            const hasParentInData = id => familyData.some(p => p.id === id);
            const roots = familyData.filter(p => 
                (!p.motherId || !hasParentInData(p.motherId)) && 
                (!p.fatherId || !hasParentInData(p.fatherId))
            );
            
            // BFS to find max depth
            let maxDepth = 1;
            const visited = new Set();
            const queue = roots.map(r => ({ id: r.id, depth: 1 }));
            
            while (queue.length > 0) {
                const { id, depth } = queue.shift();
                if (visited.has(id)) continue;
                visited.add(id);
                
                maxDepth = Math.max(maxDepth, depth);
                
                // Find children
                familyData.filter(p => p.motherId === id || p.fatherId === id)
                    .forEach(child => queue.push({ id: child.id, depth: depth + 1 }));
            }
            
            return maxDepth;
        }
        
        // Handle .ped file import (and optionally .tsv if selected together)
        async function handlePedImport(event) {
            const files = Array.from(event.target.files);
            if (files.length === 0) return;
            
            // Separate PED and TSV files
            const pedFile = files.find(f => f.name.toLowerCase().endsWith('.ped'));
            const tsvFile = files.find(f => f.name.toLowerCase().endsWith('.tsv'));
            
            if (!pedFile) {
                // If only TSV selected, treat as TSV import
                if (tsvFile) {
                    await processTsvFile(tsvFile);
                    event.target.value = '';
                    return;
                }
                alert('Please select a .ped file');
                return;
            }
            
            try {
                const text = await pedFile.text();
                const lines = text.trim().split('\n');
                
                // Clear existing data
                clearScene();
                familyData = [];
                conceptions = [];
                families = [];
                lifeEvents = [];
                familyMembers = {};
                
                // Parse .ped file
                // Format: FamilyID IndivID FatherID MotherID Sex Name [x] [z]
                // Sex: 1 = male, 2 = female
                const newPersons = [];
                const familySet = new Set();
                
                lines.forEach((line, index) => {
                    const trimmedLine = line.trim();
                    
                    // Skip empty lines and comments
                    if (!trimmedLine || trimmedLine.startsWith('#')) return;
                    
                    const parts = trimmedLine.split(/\t|\s+/);
                    if (parts.length < 6) return; // Skip invalid lines
                    
                    const [familyId, indivId, fatherId, motherId, sex, ...nameParts] = parts;
                    
                    // Handle name (may contain spaces)
                    let name = nameParts[0] || indivId;
                    let x = 0, z = 0;
                    
                    // Check if last parts are coordinates
                    if (nameParts.length >= 3 && !isNaN(parseFloat(nameParts[nameParts.length - 2]))) {
                        x = parseFloat(nameParts[nameParts.length - 2]) || 0;
                        z = parseFloat(nameParts[nameParts.length - 1]) || 0;
                        name = nameParts.slice(0, -2).join(' ') || indivId;
                    } else if (nameParts.length > 0) {
                        name = nameParts.join(' ');
                    }
                    
                    familySet.add(familyId);
                    
                    const person = {
                        id: indivId,
                        name: name,
                        sex: sex === '1' ? 'M' : 'F',
                        birthYear: null, // Will be set from TSV or calculated
                        birthMonth: 6,
                        deathYear: null,
                        motherId: motherId === '0' ? null : motherId,
                        fatherId: fatherId === '0' ? null : fatherId,
                        familyId: familyId,
                        x: x,
                        z: z
                    };
                    
                    newPersons.push(person);
                });
                
                // Build family members map
                familySet.forEach(fam => {
                    familyMembers[fam] = newPersons.filter(p => p.familyId === fam).map(p => p.id);
                });
                
                // Assign default birth years if not set (based on generation)
                assignDefaultBirthYears(newPersons);
                
                // Auto-calculate positions if not provided
                assignPositions(newPersons);
                
                // Build conceptions array
                newPersons.forEach(person => {
                    if (person.motherId && person.fatherId) {
                        const mother = newPersons.find(p => p.id === person.motherId);
                        if (mother && mother.birthYear) {
                            conceptions.push({
                                father: person.fatherId,
                                mother: person.motherId,
                                child: person.id
                            });
                        }
                    }
                });
                
                // Update global familyData
                familyData = newPersons;
                
                // Store in families array
                families = Array.from(familySet).map(fam => ({
                    id: fam,
                    name: fam,
                    members: familyMembers[fam]
                }));
                
                // If TSV file was also selected, process it before building the scene
                if (tsvFile) {
                    await processTsvFile(tsvFile);
                }
                
                // Rebuild scene
                createFamily();
                updatePedigreeInfo();
                
                console.log(`Imported ${familyData.length} persons from ${pedFile.name}` + 
                    (tsvFile ? ` with life events from ${tsvFile.name}` : ''));
                
                // Reset file input
                event.target.value = '';
                
            } catch (error) {
                console.error('Error importing .ped file:', error);
                alert('Error importing .ped file: ' + error.message);
            }
        }
        
        // Assign default birth years based on parent-child relationships
        function assignDefaultBirthYears(persons) {
            // Find roots (no parents in data)
            const personMap = new Map(persons.map(p => [p.id, p]));
            const roots = persons.filter(p => 
                (!p.motherId || !personMap.has(p.motherId)) &&
                (!p.fatherId || !personMap.has(p.fatherId))
            );
            
            // Assign birth years starting from a base year
            const baseYear = 1940;
            const generationGap = 25;
            
            const visited = new Set();
            const queue = roots.map(r => ({ person: r, generation: 0 }));
            
            while (queue.length > 0) {
                const { person, generation } = queue.shift();
                if (visited.has(person.id)) continue;
                visited.add(person.id);
                
                if (!person.birthYear) {
                    person.birthYear = baseYear + (generation * generationGap);
                }
                
                // Find children and add to queue
                persons.filter(p => p.motherId === person.id || p.fatherId === person.id)
                    .forEach(child => queue.push({ person: child, generation: generation + 1 }));
            }
            
            // Handle any unvisited persons
            persons.filter(p => !visited.has(p.id)).forEach(p => {
                if (!p.birthYear) p.birthYear = 1980;
            });
        }
        
        // Auto-assign X/Z positions for visualization
        function assignPositions(persons) {
            // Group by family
            const familyGroups = {};
            persons.forEach(p => {
                if (!familyGroups[p.familyId]) familyGroups[p.familyId] = [];
                familyGroups[p.familyId].push(p);
            });
            
            let familyOffset = 0;
            
            Object.keys(familyGroups).forEach(familyId => {
                const familyPersons = familyGroups[familyId];
                
                // Sort by birth year
                familyPersons.sort((a, b) => (a.birthYear || 2000) - (b.birthYear || 2000));
                
                // Calculate generations
                const generations = new Map();
                const personMap = new Map(familyPersons.map(p => [p.id, p]));
                
                familyPersons.forEach(person => {
                    let gen = 0;
                    let current = person;
                    while (current.motherId && personMap.has(current.motherId)) {
                        gen++;
                        current = personMap.get(current.motherId);
                    }
                    generations.set(person.id, gen);
                });
                
                // Group by generation
                const genGroups = {};
                familyPersons.forEach(person => {
                    const gen = generations.get(person.id);
                    if (!genGroups[gen]) genGroups[gen] = [];
                    genGroups[gen].push(person);
                });
                
                // Assign positions
                const genKeys = Object.keys(genGroups).map(Number).sort((a, b) => a - b);
                genKeys.forEach((gen, genIndex) => {
                    const genPersons = genGroups[gen];
                    genPersons.forEach((person, i) => {
                        // Only assign if position is 0,0 (default/unset)
                        if (person.x === 0 && person.z === 0) {
                            person.x = familyOffset + (i - (genPersons.length - 1) / 2) * 2;
                            person.z = -gen * 4;
                        }
                    });
                });
                
                familyOffset += 8; // Space between families
            });
        }
        
        // Export pedigree to .ped file
        function exportPedFile() {
            if (familyData.length === 0) {
                alert('No pedigree data to export.');
                return;
            }
            
            // Format: FamilyID IndivID FatherID MotherID Sex Name X Z
            const lines = familyData.map(person => {
                const familyId = person.familyId || 'FAM1';
                const fatherId = person.fatherId || '0';
                const motherId = person.motherId || '0';
                const sex = person.sex === 'M' ? '1' : '2';
                return `${familyId}\t${person.id}\t${fatherId}\t${motherId}\t${sex}\t${person.name}\t${person.x.toFixed(2)}\t${person.z.toFixed(2)}`;
            });
            
            const header = '# FamilyID\tIndivID\tFatherID\tMotherID\tSex\tName\tX\tZ';
            const content = header + '\n' + lines.join('\n');
            
            return content;
        }
        
        // Generate TSV content for export
        function generateTsvContent() {
            const lines = ['IndivID\tName\tDOB\tDOD\tEventType\tEventName\tOnsetYear\tSeverity\tDescription'];
            
            // Export DOB/DOD for all persons
            familyData.forEach(person => {
                const personEvents = lifeEvents.filter(e => e.personId === person.id);
                
                if (personEvents.length === 0) {
                    // Just DOB/DOD, no events
                    const dob = person.birthMonth ? 
                        `${person.birthYear}-${String(person.birthMonth).padStart(2, '0')}-01` : 
                        (person.birthYear || '');
                    const dod = person.deathYear || '';
                    lines.push(`${person.id}\t${person.name}\t${dob}\t${dod}\t\t\t\t\t`);
                } else {
                    // Include each event as a row
                    personEvents.forEach((event, idx) => {
                        const dob = idx === 0 ? (person.birthMonth ? 
                            `${person.birthYear}-${String(person.birthMonth).padStart(2, '0')}-01` : 
                            (person.birthYear || '')) : '';
                        const dod = idx === 0 ? (person.deathYear || '') : '';
                        lines.push(`${person.id}\t${person.name}\t${dob}\t${dod}\t${event.eventType}\t${event.name}\t${event.onsetYear || ''}\t${event.severity}\t${event.description}`);
                    });
                }
            });
            
            return lines.join('\n');
        }
        
        // Export to .momi (zip containing pedigree.ped + life_events.tsv)
        async function exportMomiFile() {
            if (familyData.length === 0) {
                alert('No pedigree data to export.');
                return;
            }
            
            try {
                const zip = new JSZip();
                
                // Add pedigree.ped
                const pedContent = generatePedContent();
                zip.file('pedigree.ped', pedContent);
                
                // Add life_events.tsv
                const tsvContent = generateTsvContent();
                zip.file('life_events.tsv', tsvContent);
                
                // Generate zip and download
                const blob = await zip.generateAsync({ type: 'blob' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'pedigree.momi';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                console.log('Exported pedigree.momi with pedigree.ped and life_events.tsv');
            } catch (error) {
                console.error('Error exporting .momi file:', error);
                alert('Error exporting .momi file: ' + error.message);
            }
        }
        
        // Import from .momi (zip containing pedigree.ped + life_events.tsv)
        async function handleMomiImport(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            try {
                const zip = await JSZip.loadAsync(file);
                
                // Find .ped file in zip
                const pedFileName = Object.keys(zip.files).find(name => name.toLowerCase().endsWith('.ped'));
                const tsvFileName = Object.keys(zip.files).find(name => name.toLowerCase().endsWith('.tsv'));
                
                if (!pedFileName) {
                    alert('No .ped file found in the archive');
                    return;
                }
                
                // Read PED file content
                const pedText = await zip.files[pedFileName].async('string');
                const lines = pedText.trim().split('\n');
                
                // Clear existing data
                clearScene();
                familyData = [];
                conceptions = [];
                families = [];
                lifeEvents = [];
                familyMembers = {};
                
                // Parse .ped file
                const newPersons = [];
                const familySet = new Set();
                
                lines.forEach((line) => {
                    const trimmedLine = line.trim();
                    if (!trimmedLine || trimmedLine.startsWith('#')) return;
                    
                    const parts = trimmedLine.split(/\t|\s+/);
                    if (parts.length < 6) return;
                    
                    const [familyId, indivId, fatherId, motherId, sex, ...nameParts] = parts;
                    
                    let name = nameParts[0] || indivId;
                    let x = 0, z = 0;
                    
                    if (nameParts.length >= 3 && !isNaN(parseFloat(nameParts[nameParts.length - 2]))) {
                        x = parseFloat(nameParts[nameParts.length - 2]) || 0;
                        z = parseFloat(nameParts[nameParts.length - 1]) || 0;
                        name = nameParts.slice(0, -2).join(' ') || indivId;
                    } else if (nameParts.length > 0) {
                        name = nameParts.join(' ');
                    }
                    
                    familySet.add(familyId);
                    
                    const person = {
                        id: indivId,
                        name: name,
                        sex: sex === '1' ? 'M' : 'F',
                        birthYear: null,
                        birthMonth: 6,
                        deathYear: null,
                        motherId: motherId === '0' ? null : motherId,
                        fatherId: fatherId === '0' ? null : fatherId,
                        familyId: familyId,
                        x: x,
                        z: z
                    };
                    
                    newPersons.push(person);
                });
                
                // Build family members map
                familySet.forEach(fam => {
                    familyMembers[fam] = newPersons.filter(p => p.familyId === fam).map(p => p.id);
                });
                
                // Assign default birth years
                assignDefaultBirthYears(newPersons);
                
                // Auto-calculate positions if not provided
                assignPositions(newPersons);
                
                // Build conceptions array
                newPersons.forEach(person => {
                    if (person.motherId && person.fatherId) {
                        conceptions.push({
                            father: person.fatherId,
                            mother: person.motherId,
                            child: person.id
                        });
                    }
                });
                
                // Update global familyData
                familyData = newPersons;
                
                families = Array.from(familySet).map(fam => ({
                    id: fam,
                    name: fam,
                    members: familyMembers[fam]
                }));
                
                // If TSV file exists, process it
                if (tsvFileName) {
                    const tsvText = await zip.files[tsvFileName].async('string');
                    await processTsvContent(tsvText);
                }
                
                // Rebuild scene
                createFamily();
                updatePedigreeInfo();
                
                console.log(`Imported ${familyData.length} persons from ${file.name}` + 
                    (tsvFileName ? ` with life events` : ''));
                
                event.target.value = '';
                
            } catch (error) {
                console.error('Error importing .momi file:', error);
                alert('Error importing .momi file: ' + error.message);
            }
        }
        
        // Process TSV content string (for use by both file import and zip import)
        async function processTsvContent(text) {
            const lines = text.trim().split('\n');
            
            // Parse header to determine column indices
            const header = lines[0].split('\t');
            const colIndex = {};
            header.forEach((col, i) => {
                colIndex[col.toLowerCase().trim()] = i;
            });
            
            const indivIdCol = colIndex['individid'] ?? colIndex['individ'] ?? colIndex['id'] ?? 0;
            const personNameCol = colIndex['name'] ?? -1;
            const dobCol = colIndex['dob'] ?? colIndex['birthyear'] ?? colIndex['birth'] ?? -1;
            const dodCol = colIndex['dod'] ?? colIndex['deathyear'] ?? colIndex['death'] ?? -1;
            const eventTypeCol = colIndex['eventtype'] ?? colIndex['type'] ?? -1;
            const eventNameCol = colIndex['eventname'] ?? colIndex['event'] ?? -1;
            const onsetYearCol = colIndex['onsetyear'] ?? colIndex['onset'] ?? colIndex['year'] ?? -1;
            const severityCol = colIndex['severity'] ?? -1;
            const descriptionCol = colIndex['description'] ?? colIndex['desc'] ?? -1;
            
            // Skip header, process data rows
            for (let i = 1; i < lines.length; i++) {
                const parts = lines[i].split('\t');
                if (parts.length < 2) continue;
                
                const indivId = parts[indivIdCol]?.trim();
                if (!indivId) continue;
                
                const person = familyData.find(p => p.id === indivId);
                
                if (person && personNameCol >= 0 && parts[personNameCol]) {
                    const name = parts[personNameCol].trim();
                    if (name) person.name = name;
                }
                
                if (person) {
                    if (dobCol >= 0 && parts[dobCol]) {
                        const dob = parts[dobCol].trim();
                        if (dob.includes('-') || dob.includes('/')) {
                            const dateParts = dob.includes('-') ? dob.split('-') : dob.split('/');
                            if (dateParts[0].length === 4) {
                                person.birthYear = parseInt(dateParts[0]);
                                person.birthMonth = parseInt(dateParts[1]) || 6;
                            } else {
                                person.birthYear = parseInt(dateParts[2]);
                                person.birthMonth = parseInt(dateParts[0]) || 6;
                            }
                        } else {
                            person.birthYear = parseInt(dob);
                        }
                    }
                    
                    if (dodCol >= 0 && parts[dodCol]) {
                        const dod = parts[dodCol].trim();
                        if (dod.includes('-') || dod.includes('/')) {
                            const dateParts = dod.includes('-') ? dod.split('-') : dod.split('/');
                            person.deathYear = parseInt(dateParts[0].length === 4 ? dateParts[0] : dateParts[2]);
                        } else {
                            person.deathYear = parseInt(dod);
                        }
                    }
                }
                
                // Add life event if present
                if (eventTypeCol >= 0 && parts[eventTypeCol]?.trim()) {
                    const event = {
                        personId: indivId,
                        eventType: parts[eventTypeCol].trim(),
                        name: eventNameCol >= 0 ? (parts[eventNameCol]?.trim() || '') : '',
                        onsetYear: onsetYearCol >= 0 ? parseInt(parts[onsetYearCol]) || null : null,
                        severity: severityCol >= 0 ? (parts[severityCol]?.trim() || 'mild') : 'mild',
                        description: descriptionCol >= 0 ? (parts[descriptionCol]?.trim() || '') : ''
                    };
                    lifeEvents.push(event);
                }
            }
        }
        
        // Generate PED content for export
        function generatePedContent() {
            if (familyData.length === 0) {
                return '';
            }
            
            const lines = familyData.map(person => {
                const familyId = person.familyId || 'FAM1';
                const fatherId = person.fatherId || '0';
                const motherId = person.motherId || '0';
                const sex = person.sex === 'M' ? '1' : '2';
                return `${familyId}\t${person.id}\t${fatherId}\t${motherId}\t${sex}\t${person.name}\t${person.x.toFixed(2)}\t${person.z.toFixed(2)}`;
            });
            
            const header = '# FamilyID\tIndivID\tFatherID\tMotherID\tSex\tName\tX\tZ';
            return header + '\n' + lines.join('\n');
        }
        
        // Keep legacy exportPedFile for compatibility but use new generator
        function exportPedFile() {
            if (familyData.length === 0) {
                alert('No pedigree data to export.');
                return;
            }
            const content = generatePedContent();
            downloadFile(content, 'pedigree.ped', 'text/plain');
        }
        
        // Handle .tsv file import (DOB, DOD, life events) - wrapper for file input
        async function handleTsvImport(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            await processTsvFile(file);
            
            // If there were DOB/DOD changes, rebuild the scene
            if (familyData.length > 0) {
                clearScene();
                createFamily();
            }
            
            // Re-add life event markers if visible
            if (lifeEventsVisible) {
                toggleLifeEvents(); // Turn off
                toggleLifeEvents(); // Turn on to refresh
            }
            
            updatePedigreeInfo();
            event.target.value = '';
        }
        
        // Process TSV file contents - can be called from PED import or standalone
        async function processTsvFile(file) {
            try {
                const text = await file.text();
                const lines = text.trim().split('\n');
                
                // Clear existing life events for persons that will be updated
                const newEvents = [];
                const updatedPersons = new Set();
                
                // Parse header to determine column indices
                const header = lines[0].split('\t');
                const colIndex = {};
                header.forEach((col, i) => {
                    colIndex[col.toLowerCase().trim()] = i;
                });
                
                // Expected columns: IndivID, Name, DOB, DOD, EventType, EventName, OnsetYear, Severity, Description
                const indivIdCol = colIndex['individid'] ?? colIndex['individ'] ?? colIndex['id'] ?? 0;
                const personNameCol = colIndex['name'] ?? -1;  // Person's name (optional)
                const dobCol = colIndex['dob'] ?? colIndex['birthyear'] ?? colIndex['birth'] ?? -1;
                const dodCol = colIndex['dod'] ?? colIndex['deathyear'] ?? colIndex['death'] ?? -1;
                const eventTypeCol = colIndex['eventtype'] ?? colIndex['type'] ?? -1;
                const eventNameCol = colIndex['eventname'] ?? colIndex['event'] ?? -1;
                const onsetYearCol = colIndex['onsetyear'] ?? colIndex['onset'] ?? colIndex['year'] ?? -1;
                const severityCol = colIndex['severity'] ?? -1;
                const descriptionCol = colIndex['description'] ?? colIndex['desc'] ?? -1;
                
                // Skip header, process data rows
                for (let i = 1; i < lines.length; i++) {
                    const parts = lines[i].split('\t');
                    if (parts.length < 2) continue;
                    
                    const indivId = parts[indivIdCol]?.trim();
                    if (!indivId) continue;
                    
                    // Find person in familyData
                    const person = familyData.find(p => p.id === indivId);
                    
                    // Update person's name if provided
                    if (person && personNameCol >= 0 && parts[personNameCol]) {
                        const name = parts[personNameCol].trim();
                        if (name) {
                            person.name = name;
                        }
                    }
                    
                    // Update DOB/DOD if provided
                    if (person) {
                        if (dobCol >= 0 && parts[dobCol]) {
                            const dob = parts[dobCol].trim();
                            if (dob.includes('-') || dob.includes('/')) {
                                // Parse date format YYYY-MM-DD or MM/DD/YYYY
                                const dateParts = dob.includes('-') ? dob.split('-') : dob.split('/');
                                if (dateParts[0].length === 4) {
                                    person.birthYear = parseInt(dateParts[0]);
                                    person.birthMonth = parseInt(dateParts[1]) || 6;
                                } else {
                                    person.birthYear = parseInt(dateParts[2]);
                                    person.birthMonth = parseInt(dateParts[0]) || 6;
                                }
                            } else {
                                person.birthYear = parseInt(dob);
                            }
                        }
                        
                        if (dodCol >= 0 && parts[dodCol]) {
                            const dod = parts[dodCol].trim();
                            if (dod && dod !== '0' && dod !== '') {
                                if (dod.includes('-') || dod.includes('/')) {
                                    const dateParts = dod.includes('-') ? dod.split('-') : dod.split('/');
                                    person.deathYear = dateParts[0].length === 4 ? parseInt(dateParts[0]) : parseInt(dateParts[2]);
                                } else {
                                    person.deathYear = parseInt(dod) || null;
                                }
                            }
                        }
                        
                        updatedPersons.add(indivId);
                    }
                    
                    // Add life event if provided
                    if (eventTypeCol >= 0 && parts[eventTypeCol] && parts[eventTypeCol].trim()) {
                        const eventData = {
                            id: `evt_${i}`,
                            personId: indivId,
                            eventType: parts[eventTypeCol]?.trim() || 'event',
                            name: parts[eventNameCol]?.trim() || 'Event',
                            onsetYear: parseInt(parts[onsetYearCol]) || null,
                            severity: parts[severityCol]?.trim() || 'unknown',
                            description: parts[descriptionCol]?.trim() || ''
                        };
                        
                        if (eventData.onsetYear) {
                            newEvents.push(eventData);
                        }
                    }
                }
                
                // Merge new events with existing
                // Remove old events for updated persons
                lifeEvents = lifeEvents.filter(e => !updatedPersons.has(e.personId));
                lifeEvents = lifeEvents.concat(newEvents);
                
                console.log(`Processed TSV: ${newEvents.length} events, ${updatedPersons.size} persons updated from ${file.name}`);
                
            } catch (error) {
                console.error('Error processing .tsv file:', error);
                alert('Error processing .tsv file: ' + error.message);
            }
        }
        
        // Export life events and DOB/DOD to .tsv file
        function exportTsvFile() {
            if (familyData.length === 0) {
                alert('No data to export.');
                return;
            }
            
            const lines = ['IndivID\tDOB\tDOD\tEventType\tEventName\tOnsetYear\tSeverity\tDescription'];
            
            // Export DOB/DOD for all persons
            familyData.forEach(person => {
                const personEvents = lifeEvents.filter(e => e.personId === person.id);
                
                if (personEvents.length === 0) {
                    // Just DOB/DOD, no events
                    const dob = person.birthMonth ? 
                        `${person.birthYear}-${String(person.birthMonth).padStart(2, '0')}-01` : 
                        (person.birthYear || '');
                    const dod = person.deathYear || '';
                    lines.push(`${person.id}\t${dob}\t${dod}\t\t\t\t\t`);
                } else {
                    // Include each event as a row
                    personEvents.forEach((event, idx) => {
                        const dob = idx === 0 ? (person.birthMonth ? 
                            `${person.birthYear}-${String(person.birthMonth).padStart(2, '0')}-01` : 
                            (person.birthYear || '')) : '';
                        const dod = idx === 0 ? (person.deathYear || '') : '';
                        lines.push(`${person.id}\t${dob}\t${dod}\t${event.eventType}\t${event.name}\t${event.onsetYear || ''}\t${event.severity}\t${event.description}`);
                    });
                }
            });
            
            const content = lines.join('\n');
            downloadFile(content, 'life_events.tsv', 'text/tab-separated-values');
        }
        
        // Helper function to download a file
        function downloadFile(content, filename, mimeType) {
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        // ============ END IMPORT/EXPORT FUNCTIONS ============

        function onWindowResize() {
            const container = document.getElementById('canvas-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // Initialize and start
        async function startVisualization() {
            try {
                console.log('Starting visualization...');
                init();
                console.log('Initialized scene');
                
                // Load data from API
                const dataLoaded = await loadDataFromAPI();
                console.log('Data loaded:', dataLoaded);
                if (!dataLoaded) {
                    return; // Error already displayed by loadDataFromAPI
                }
                
                console.log('Creating family...');
                createFamily();
                
                // Create genome legend if genomes are visible
                if (genomesVisible) {
                    createGenomeLegend();
                }
                
                console.log('Starting animation...');
                animate();
                
                // Hide loading screen
                document.getElementById('loading').style.display = 'none';
                console.log('Visualization complete');
            } catch (error) {
                console.error('Error initializing visualization:', error);
                console.error('Stack trace:', error.stack);
                document.getElementById('loading').innerHTML = 'Error loading visualization. Check console for details.<br><br>' + error.message + '<br><br>' + error.stack;
                document.getElementById('loading').style.background = 'rgba(255, 0, 0, 0.7)';
            }
        }

        // ============================================
        // MOUNT IMPROBABLE ANIMATION
        // ============================================
        
        let miScene, miCamera, miRenderer, miControls, miAnimationId;
        let miAnimationTime = 0;
        let miIsPlaying = true;
        let miStacksMesh = null;
        
        // Mountain parameters - represents 3.8 billion years of life
        const MI_MOUNTAIN_HEIGHT = 380; // Y units (scaled for visualization)
        const MI_MOUNTAIN_BASE_RADIUS = 15; // Narrow at origin of life
        const MI_MOUNTAIN_TOP_RADIUS = 40; // Wide at present
        const MI_STACKS_PER_SLICE = 60;
        const MI_SLICE_STEP = 2; // Y units between slices
        
        // Sector colors representing different domains of life
        const MI_SECTORS = [
            { name: 'Bacteria', color: 0x00ffff },
            { name: 'Archaea', color: 0xff00ff },
            { name: 'Mammals', color: 0xff6699 },
            { name: 'Birds', color: 0xff9944 },
            { name: 'Reptiles', color: 0x66ff66 },
            { name: 'Amphibians', color: 0x44ffaa },
            { name: 'Fish', color: 0x4488ff },
            { name: 'Insects', color: 0xffaa44 },
            { name: 'Plants', color: 0x44ff44 },
            { name: 'Fungi', color: 0xaa88ff },
            { name: 'Other Animals', color: 0xffff44 }
        ];
        
        // Timeline markers with evolutionary milestones
        const MI_TIMELINE = [
            { y: 0, text: 'Present Day', timeMa: 0, color: '#00ff88' },
            { y: -4, text: 'First Humans (300 ka)', timeMa: 0.3, color: '#ffaa44' },
            { y: -13, text: 'K-T Extinction (66 Ma)', timeMa: 66, color: '#ff4444' },
            { y: -40, text: 'First Mammals (200 Ma)', timeMa: 200, color: '#ff6699' },
            { y: -105, text: 'First Fish (525 Ma)', timeMa: 525, color: '#4488ff' },
            { y: -108, text: 'Cambrian Explosion (541 Ma)', timeMa: 541, color: '#ffff00' },
            { y: -160, text: 'First Animals (800 Ma)', timeMa: 800, color: '#ff88ff' },
            { y: -120, text: 'Sexual Reproduction (1.2 Ga)', timeMa: 1200, color: '#ff66cc' },
            { y: -240, text: 'First Eukaryotes (2.1 Ga)', timeMa: 2100, color: '#ff00ff' },
            { y: -300, text: 'Great Oxidation (2.4 Ga)', timeMa: 2400, color: '#00ffff' },
            { y: -380, text: 'Origin of Life (3.8 Ga)', timeMa: 3800, color: '#ffffff' }
        ];
        
        // Narration sequence
        const MI_NARRATION = [
            { time: 0, duration: 6000, text: "This is Mount Improbable ‚Äî a visualization of 3.8 billion years of life on Earth." },
            { time: 6000, duration: 5000, text: "Each vertical stack represents a living being. Males are square, females are round." },
            { time: 11000, duration: 5000, text: "At the base is the origin of life ‚Äî LUCA, the Last Universal Common Ancestor." },
            { time: 16000, duration: 5000, text: "For billions of years, only bacteria and archaea existed, reproducing asexually." },
            { time: 21000, duration: 6000, text: "Around 1.2 billion years ago, sexual reproduction evolved. Now males and females combine their genes." },
            { time: 27000, duration: 5000, text: "Yellow lines show conception ‚Äî where father and mother meet. Green lines show birth." },
            { time: 32000, duration: 5000, text: "Species cluster together. As we climb the mountain, species come and go, evolve and diversify." },
            { time: 37000, duration: 5000, text: "The mountain widens toward the present. More species alive today than ever before." },
            { time: 42000, duration: 6000, text: "And at the very summit ‚Äî humans. Your family. YOU. The peak of your own ancestral mountain." },
            { time: 47000, duration: 5000, text: "In MOMI, you visualize your personal summit ‚Äî the last few generations of YOUR climb." },
        ];
        
        function showMIMenu() {
            document.getElementById('mi-menu-modal').classList.add('visible');
        }
        
        function closeMIMenu() {
            document.getElementById('mi-menu-modal').classList.remove('visible');
        }
        
        function showMIAnimation() {
            closeMIMenu();
            document.getElementById('mi-animation-modal').classList.add('visible');
            initMIAnimation();
        }
        
        function closeMIAnimation() {
            document.getElementById('mi-animation-modal').classList.remove('visible');
            if (miAnimationId) {
                cancelAnimationFrame(miAnimationId);
                miAnimationId = null;
            }
            // Clean up Three.js resources
            if (miRenderer) {
                miRenderer.dispose();
                const container = document.getElementById('mi-animation-container');
                if (container.firstChild) {
                    container.removeChild(container.firstChild);
                }
            }
            if (miStacksMesh) {
                miStacksMesh.geometry.dispose();
                miStacksMesh.material.dispose();
                miStacksMesh = null;
            }
            miScene = null;
            miCamera = null;
            miRenderer = null;
            miControls = null;
        }
        
        function miAnimationToggle() {
            miIsPlaying = !miIsPlaying;
            document.getElementById('mi-play-btn').textContent = miIsPlaying ? '‚è∏ Pause' : '‚ñ∂ Play';
        }
        
        // Speed control variable
        let miAnimationSpeed = 1.0;
        
        function setMISpeed(speed) {
            miAnimationSpeed = parseFloat(speed);
            updateSpeedDisplay(speed);
        }
        
        function updateSpeedDisplay(speed) {
            document.getElementById('mi-speed-value').textContent = parseFloat(speed).toFixed(1) + 'x';
        }
        
        function jumpToEpoch(targetY) {
            if (!miCamera || !miControls) return;
            
            // Pause animation during jump
            miIsPlaying = false;
            document.getElementById('mi-play-btn').textContent = '‚ñ∂ Play';
            
            // Calculate the animation time that corresponds to this Y position
            // The animation runs from y=50 to y=-MI_MOUNTAIN_HEIGHT over ~300 seconds
            const totalYRange = 50 + MI_MOUNTAIN_HEIGHT; // 50 to -380 = 430 units
            const targetProgress = (50 - targetY) / totalYRange;
            miAnimationTime = targetProgress * 300; // Map to animation time
            
            // Position camera at this epoch with a nice viewing angle
            const viewRadius = 80 + Math.abs(targetY) * 0.3; // Farther away at deeper times
            const angle = (targetProgress * Math.PI * 6) + Math.PI / 4; // Spiral position
            
            miCamera.position.set(
                Math.sin(angle) * viewRadius,
                targetY + 30, // Above the target point
                Math.cos(angle) * viewRadius
            );
            
            miControls.target.set(0, targetY, 0);
            miCamera.lookAt(0, targetY, 0);
            miControls.update();
            
            // Update timeline display based on Y position
            updateTimelineDisplay(targetY);
        }
        
        function updateTimelineDisplay(y) {
            const timelineDisplay = document.getElementById('mi-timeline-display');
            if (y >= -5) {
                timelineDisplay.textContent = 'Present Day';
            } else if (y >= -20) {
                timelineDisplay.textContent = 'Cenozoic Era (~66 Ma)';
            } else if (y >= -50) {
                timelineDisplay.textContent = 'Mesozoic Era (~250 Ma)';
            } else if (y >= -108) {
                timelineDisplay.textContent = 'Paleozoic Era (~541 Ma)';
            } else if (y >= -200) {
                timelineDisplay.textContent = 'Proterozoic Eon (~1 Ga)';
            } else if (y >= -300) {
                timelineDisplay.textContent = 'Archean Eon (~2.5 Ga)';
            } else {
                timelineDisplay.textContent = 'Hadean Eon (~4 Ga)';
            }
        }
        
        function miAnimationRestart() {
            miAnimationTime = 0;
            miIsPlaying = true;
            miAnimationSpeed = 1.0;
            document.getElementById('mi-play-btn').textContent = '‚è∏ Pause';
            document.getElementById('mi-speed-slider').value = 1;
            document.getElementById('mi-speed-value').textContent = '1.0x';
            
            // Reset camera position
            if (miCamera) {
                miCamera.position.set(0, 50, 120);
                miCamera.lookAt(0, 0, 0);
                if (miControls) {
                    miControls.target.set(0, 0, 0);
                }
            }
            
            // Reset title visibility
            document.getElementById('mi-animation-title').classList.remove('visible');
            setTimeout(() => {
                document.getElementById('mi-animation-title').classList.add('visible');
            }, 500);
        }
        
        function initMIAnimation() {
            const container = document.getElementById('mi-animation-container');
            
            // Scene
            miScene = new THREE.Scene();
            miScene.background = new THREE.Color(0x000510);
            miScene.fog = new THREE.Fog(0x000510, 100, 500);
            
            // Camera - start at present day summit
            miCamera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 1000);
            miCamera.position.set(0, 50, 120);
            miCamera.lookAt(0, 0, 0);
            
            // Renderer
            miRenderer = new THREE.WebGLRenderer({ antialias: true });
            miRenderer.setSize(container.clientWidth, container.clientHeight);
            miRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            miRenderer.setClearColor(0x000510);
            container.appendChild(miRenderer.domElement);
            
            // OrbitControls for manual exploration
            miControls = new THREE.OrbitControls(miCamera, miRenderer.domElement);
            miControls.enableDamping = true;
            miControls.dampingFactor = 0.05;
            miControls.minDistance = 20;
            miControls.maxDistance = 400;
            miControls.target.set(0, 0, 0);
            
            // Lights - enhanced for warm glow effect
            miScene.add(new THREE.AmbientLight(0xffeedd, 0.3)); // Warm ambient
            
            const sunLight = new THREE.DirectionalLight(0xffffee, 1.2);
            sunLight.position.set(50, 200, 100);
            miScene.add(sunLight);
            
            // Warm point light at the summit (present day) - consciousness glow
            const summitGlow = new THREE.PointLight(0xffaa44, 1.5, 150);
            summitGlow.position.set(0, 30, 0);
            miScene.add(summitGlow);
            
            // Cool point light at the base (origin) - primordial
            const originGlow = new THREE.PointLight(0x4466ff, 0.8, 200);
            originGlow.position.set(0, -MI_MOUNTAIN_HEIGHT - 20, 0);
            miScene.add(originGlow);
            
            // Hemisphere light for natural feel - warm sky, cool ground
            const hemiLight = new THREE.HemisphereLight(0xffddaa, 0x4466aa, 0.4);
            miScene.add(hemiLight);
            
            // Generate the mountain of life
            createMIMountain();
            
            // Add timeline markers
            createMITimelineMarkers();
            
            // Add starfield background
            addMIStarfield();
            
            // Show title
            setTimeout(() => {
                document.getElementById('mi-animation-title').classList.add('visible');
            }, 500);
            
            // Hide title after a few seconds
            setTimeout(() => {
                document.getElementById('mi-animation-title').classList.remove('visible');
            }, 5000);
            
            // Handle window resize
            window.addEventListener('resize', onMIResize);
            
            // Start animation
            miAnimationTime = 0;
            miIsPlaying = true;
            animateMI();
        }
        
        function createMIMountain() {
            // Store individuals for drawing connections
            const allIndividuals = [];
            
            // Create geometry for males (square/box) and females (rounded/cylinder)
            const maleGeometry = new THREE.BoxGeometry(0.3, 1, 0.3);
            const femaleGeometry = new THREE.CylinderGeometry(0.18, 0.18, 1, 12);
            
            // Materials with warm glow
            const maleMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xffffff,
                side: THREE.DoubleSide,
                shininess: 60,
                emissive: 0x442200,
                emissiveIntensity: 0.4
            });
            const femaleMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xffffff,
                side: THREE.DoubleSide,
                shininess: 60,
                emissive: 0x442200,
                emissiveIntensity: 0.4
            });
            
            const totalSlices = Math.floor(MI_MOUNTAIN_HEIGHT / MI_SLICE_STEP);
            const maxStacks = totalSlices * MI_STACKS_PER_SLICE;
            
            // Create separate instanced meshes for males and females
            const malesMesh = new THREE.InstancedMesh(maleGeometry, maleMaterial, Math.floor(maxStacks / 2));
            const femalesMesh = new THREE.InstancedMesh(femaleGeometry, femaleMaterial, Math.floor(maxStacks / 2));
            
            let maleIndex = 0;
            let femaleIndex = 0;
            const matrix = new THREE.Matrix4();
            const tempMatrix = new THREE.Matrix4();
            
            // Sexual reproduction emerged around 1.2 billion years ago (t ~ 0.68)
            const SEXUAL_REPRODUCTION_TIME = 0.68;
            
            // Track species - each species is a cluster of individuals
            let speciesCounter = 0;
            const speciesRegistry = new Map(); // speciesId -> { sector, startTime, endTime, individuals }
            
            for (let slice = 0; slice < totalSlices; slice++) {
                const y = -slice * MI_SLICE_STEP;
                const t = slice / totalSlices; // 0 = present, 1 = origin
                
                // Radius widens toward present
                const radius = MI_MOUNTAIN_TOP_RADIUS - (MI_MOUNTAIN_TOP_RADIUS - MI_MOUNTAIN_BASE_RADIUS) * t;
                
                // Determine active sectors at this time depth
                let activeSectors = [...MI_SECTORS];
                if (t > 0.95) {
                    activeSectors = MI_SECTORS.filter(s => ['Bacteria', 'Archaea'].includes(s.name));
                } else if (t > 0.7) {
                    activeSectors = MI_SECTORS.filter(s => ['Bacteria', 'Archaea', 'Fungi', 'Plants'].includes(s.name));
                } else if (t > 0.4) {
                    activeSectors = MI_SECTORS.filter(s => !['Mammals', 'Birds'].includes(s.name));
                } else if (t > 0.15) {
                    activeSectors = MI_SECTORS.filter(s => s.name !== 'Mammals');
                }
                
                // Density increases toward present
                const density = Math.pow(1 - t, 0.5);
                const stacksThisSlice = Math.floor(MI_STACKS_PER_SLICE * Math.max(0.1, density));
                
                // Create/update species for this time slice
                const speciesPerSector = Math.max(1, Math.floor(3 * (1 - t))); // More species toward present
                
                for (let i = 0; i < stacksThisSlice; i++) {
                    const sector = activeSectors[i % activeSectors.length];
                    const sectorIdx = MI_SECTORS.indexOf(sector);
                    
                    // Assign to a species within this sector
                    const speciesInSector = (i % speciesPerSector);
                    const speciesId = `${sector.name}_${Math.floor(t * 20)}_${speciesInSector}`;
                    
                    // Species clustering - individuals of same species are closer together
                    const speciesAngleBase = (sectorIdx / MI_SECTORS.length) * Math.PI * 2;
                    const speciesOffset = (speciesInSector / speciesPerSector) * 0.5;
                    const individualOffset = (Math.random() - 0.5) * 0.3;
                    const angle = speciesAngleBase + speciesOffset + individualOffset;
                    
                    const r = radius * (0.6 + Math.random() * 0.35);
                    const x = Math.cos(angle) * r;
                    const z = Math.sin(angle) * r;
                    
                    // Stack height (lifespan)
                    const stackHeight = 1.5 + Math.random() * 2;
                    
                    // Determine sex - only after sexual reproduction evolved
                    const hasSexualReproduction = t < SEXUAL_REPRODUCTION_TIME;
                    const isMale = hasSexualReproduction ? (Math.random() < 0.5) : null;
                    
                    // Color calculation
                    const warmth = 1 - t;
                    const sectorColor = new THREE.Color(sector.color);
                    const coldColor = new THREE.Color(0x1a0a30);
                    const warmColor = new THREE.Color(0xffaa44);
                    const baseWarmth = new THREE.Color().lerpColors(coldColor, warmColor, Math.pow(warmth, 0.7));
                    
                    const finalColor = new THREE.Color();
                    finalColor.copy(sectorColor);
                    finalColor.lerp(baseWarmth, 0.5);
                    finalColor.lerp(new THREE.Color(0xffffee), warmth * 0.3);
                    
                    // Tint males slightly blue, females slightly pink (for sexual species)
                    if (hasSexualReproduction) {
                        if (isMale) {
                            finalColor.lerp(new THREE.Color(0x6688ff), 0.2);
                        } else {
                            finalColor.lerp(new THREE.Color(0xff88aa), 0.2);
                        }
                    }
                    
                    // Build transformation matrix
                    matrix.identity();
                    tempMatrix.makeScale(1, stackHeight, 1);
                    matrix.multiply(tempMatrix);
                    matrix.setPosition(x, y + stackHeight / 2, z);
                    
                    // Store individual data
                    const individual = {
                        x, y, z,
                        stackHeight,
                        isMale,
                        hasSexualReproduction,
                        sector: sector.name,
                        speciesId,
                        timeDepth: t,
                        topY: y + stackHeight,
                        bottomY: y
                    };
                    allIndividuals.push(individual);
                    
                    // Add to appropriate mesh
                    if (hasSexualReproduction && isMale) {
                        if (maleIndex < Math.floor(maxStacks / 2)) {
                            malesMesh.setMatrixAt(maleIndex, matrix);
                            malesMesh.setColorAt(maleIndex, finalColor);
                            individual.meshType = 'male';
                            individual.meshIndex = maleIndex;
                            maleIndex++;
                        }
                    } else {
                        if (femaleIndex < Math.floor(maxStacks / 2)) {
                            femalesMesh.setMatrixAt(femaleIndex, matrix);
                            femalesMesh.setColorAt(femaleIndex, finalColor);
                            individual.meshType = 'female';
                            individual.meshIndex = femaleIndex;
                            femaleIndex++;
                        }
                    }
                }
            }
            
            // Update meshes
            malesMesh.count = maleIndex;
            malesMesh.instanceMatrix.needsUpdate = true;
            if (malesMesh.instanceColor) malesMesh.instanceColor.needsUpdate = true;
            
            femalesMesh.count = femaleIndex;
            femalesMesh.instanceMatrix.needsUpdate = true;
            if (femalesMesh.instanceColor) femalesMesh.instanceColor.needsUpdate = true;
            
            miScene.add(malesMesh);
            miScene.add(femalesMesh);
            
            // Create conception and birth lines for a sample of species clusters
            createReproductionLines(allIndividuals);
            
            // Create species boundary visualizations
            createSpeciesClusters(allIndividuals);
            
            // Add ground plane at origin of life
            const groundGeometry = new THREE.CircleGeometry(MI_MOUNTAIN_BASE_RADIUS * 1.5, 64);
            const groundMaterial = new THREE.MeshPhongMaterial({
                color: 0x111122,
                transparent: true,
                opacity: 0.5,
                side: THREE.DoubleSide
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -MI_MOUNTAIN_HEIGHT - 2;
            miScene.add(ground);
            
            // Add central time axis
            const axisGeometry = new THREE.CylinderGeometry(0.3, 0.3, MI_MOUNTAIN_HEIGHT, 16);
            const axisMaterial = new THREE.MeshPhongMaterial({
                color: 0x444466,
                transparent: true,
                opacity: 0.3
            });
            const axis = new THREE.Mesh(axisGeometry, axisMaterial);
            axis.position.y = -MI_MOUNTAIN_HEIGHT / 2;
            miScene.add(axis);
        }
        
        function createReproductionLines(individuals) {
            // Create conception lines (yellow) between parents and birth lines (green) to children
            // Only for sexual species (after ~1.2 Ga)
            
            const conceptionLineMaterial = new THREE.LineBasicMaterial({ 
                color: 0xffcc00, 
                transparent: true, 
                opacity: 0.6 
            });
            const birthLineMaterial = new THREE.LineBasicMaterial({ 
                color: 0x44ff88, 
                transparent: true, 
                opacity: 0.5 
            });
            
            // Group individuals by species
            const speciesGroups = new Map();
            individuals.forEach(ind => {
                if (!ind.hasSexualReproduction) return;
                if (!speciesGroups.has(ind.speciesId)) {
                    speciesGroups.set(ind.speciesId, { males: [], females: [] });
                }
                if (ind.isMale) {
                    speciesGroups.get(ind.speciesId).males.push(ind);
                } else {
                    speciesGroups.get(ind.speciesId).females.push(ind);
                }
            });
            
            // For each species, create some family connections
            let lineCount = 0;
            const maxLines = 500; // Limit for performance
            
            speciesGroups.forEach((group, speciesId) => {
                if (lineCount >= maxLines) return;
                if (group.males.length === 0 || group.females.length === 0) return;
                
                // Sample some breeding pairs
                const numPairs = Math.min(3, group.males.length, group.females.length);
                
                for (let p = 0; p < numPairs && lineCount < maxLines; p++) {
                    const father = group.males[p % group.males.length];
                    const mother = group.females[p % group.females.length];
                    
                    // Conception line - connects father to mother at conception point
                    const conceptionY = Math.min(father.topY, mother.topY) - 0.5;
                    const conceptionX = (father.x + mother.x) / 2;
                    const conceptionZ = (father.z + mother.z) / 2;
                    
                    // Line from father to conception point
                    const fatherToConception = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(father.x, conceptionY, father.z),
                        new THREE.Vector3(conceptionX, conceptionY, conceptionZ)
                    ]);
                    const fatherLine = new THREE.Line(fatherToConception, conceptionLineMaterial);
                    miScene.add(fatherLine);
                    
                    // Line from mother to conception point
                    const motherToConception = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(mother.x, conceptionY, mother.z),
                        new THREE.Vector3(conceptionX, conceptionY, conceptionZ)
                    ]);
                    const motherLine = new THREE.Line(motherToConception, conceptionLineMaterial);
                    miScene.add(motherLine);
                    
                    // Conception sphere (yellow)
                    const conceptionSphere = new THREE.Mesh(
                        new THREE.SphereGeometry(0.15, 8, 8),
                        new THREE.MeshPhongMaterial({ 
                            color: 0xffcc00, 
                            emissive: 0xffcc00, 
                            emissiveIntensity: 0.5 
                        })
                    );
                    conceptionSphere.position.set(conceptionX, conceptionY, conceptionZ);
                    miScene.add(conceptionSphere);
                    
                    // Find potential children (individuals nearby and slightly "younger" in time)
                    const childCandidates = individuals.filter(ind => 
                        ind.speciesId === speciesId &&
                        ind.bottomY > conceptionY - 5 && 
                        ind.bottomY < conceptionY + 2 &&
                        Math.abs(ind.x - conceptionX) < 5 &&
                        Math.abs(ind.z - conceptionZ) < 5 &&
                        ind !== father && ind !== mother
                    );
                    
                    // Birth lines - from conception to children
                    const numChildren = Math.min(2, childCandidates.length);
                    for (let c = 0; c < numChildren; c++) {
                        const child = childCandidates[c];
                        
                        // Gestation line (inside mother)
                        const gestationEnd = child.bottomY;
                        const gestationLine = new THREE.BufferGeometry().setFromPoints([
                            new THREE.Vector3(conceptionX, conceptionY, conceptionZ),
                            new THREE.Vector3(mother.x, gestationEnd + 0.5, mother.z)
                        ]);
                        const gestLine = new THREE.Line(gestationLine, new THREE.LineBasicMaterial({ 
                            color: 0xff88aa, 
                            transparent: true, 
                            opacity: 0.4 
                        }));
                        miScene.add(gestLine);
                        
                        // Birth line (green) - from mother to child's base
                        const birthLine = new THREE.BufferGeometry().setFromPoints([
                            new THREE.Vector3(mother.x, gestationEnd + 0.5, mother.z),
                            new THREE.Vector3(child.x, child.bottomY, child.z)
                        ]);
                        const bLine = new THREE.Line(birthLine, birthLineMaterial);
                        miScene.add(bLine);
                        
                        // Birth sphere (green)
                        const birthSphere = new THREE.Mesh(
                            new THREE.SphereGeometry(0.12, 8, 8),
                            new THREE.MeshPhongMaterial({ 
                                color: 0x44ff88, 
                                emissive: 0x44ff88, 
                                emissiveIntensity: 0.5 
                            })
                        );
                        birthSphere.position.set(child.x, child.bottomY, child.z);
                        miScene.add(birthSphere);
                        
                        lineCount++;
                    }
                    
                    lineCount++;
                }
            });
            
            console.log(`Created ${lineCount} reproduction connection sets`);
        }
        
        function createSpeciesClusters(individuals) {
            // Create subtle boundaries/halos around species clusters
            // Group by species
            const speciesGroups = new Map();
            individuals.forEach(ind => {
                if (!speciesGroups.has(ind.speciesId)) {
                    speciesGroups.set(ind.speciesId, []);
                }
                speciesGroups.get(ind.speciesId).push(ind);
            });
            
            // For larger species groups, create a subtle boundary ring
            speciesGroups.forEach((members, speciesId) => {
                if (members.length < 5) return; // Skip small groups
                
                // Calculate bounding circle for species
                let sumX = 0, sumZ = 0, avgY = 0;
                members.forEach(m => {
                    sumX += m.x;
                    sumZ += m.z;
                    avgY += m.y;
                });
                const centerX = sumX / members.length;
                const centerZ = sumZ / members.length;
                avgY = avgY / members.length;
                
                // Calculate radius
                let maxDist = 0;
                members.forEach(m => {
                    const dist = Math.sqrt((m.x - centerX) ** 2 + (m.z - centerZ) ** 2);
                    maxDist = Math.max(maxDist, dist);
                });
                
                // Only create rings for reasonably sized species clusters
                if (maxDist < 1 || maxDist > 15) return;
                
                // Get sector color for this species
                const sector = MI_SECTORS.find(s => speciesId.startsWith(s.name));
                const color = sector ? sector.color : 0x888888;
                
                // Create a subtle ring around the species
                const ringGeometry = new THREE.RingGeometry(maxDist * 0.9, maxDist * 1.1, 32);
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.1,
                    side: THREE.DoubleSide
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.position.set(centerX, avgY, centerZ);
                ring.rotation.x = -Math.PI / 2;
                miScene.add(ring);
            });
        }

        function createMITimelineMarkers() {
            // Create geological time scale on the side
            createGeologicalTimeScale();
            
            // Create 3D text sprites for timeline markers
            MI_TIMELINE.forEach(marker => {
                // Create ring at this time level
                const ringGeometry = new THREE.RingGeometry(
                    MI_MOUNTAIN_TOP_RADIUS - (MI_MOUNTAIN_TOP_RADIUS - MI_MOUNTAIN_BASE_RADIUS) * (-marker.y / MI_MOUNTAIN_HEIGHT) - 2,
                    MI_MOUNTAIN_TOP_RADIUS - (MI_MOUNTAIN_TOP_RADIUS - MI_MOUNTAIN_BASE_RADIUS) * (-marker.y / MI_MOUNTAIN_HEIGHT) + 2,
                    64
                );
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: parseInt(marker.color.replace('#', '0x')),
                    transparent: true,
                    opacity: 0.3,
                    side: THREE.DoubleSide
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.rotation.x = -Math.PI / 2;
                ring.position.y = marker.y;
                miScene.add(ring);
                
                // Create label sprite
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 512;
                canvas.height = 64;
                
                context.fillStyle = marker.color;
                context.font = 'Bold 28px Arial';
                context.textAlign = 'left';
                context.fillText(marker.text, 10, 45);
                
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ 
                    map: texture,
                    transparent: true
                });
                const sprite = new THREE.Sprite(spriteMaterial);
                
                // Position label outside the mountain
                const labelRadius = MI_MOUNTAIN_TOP_RADIUS - (MI_MOUNTAIN_TOP_RADIUS - MI_MOUNTAIN_BASE_RADIUS) * (-marker.y / MI_MOUNTAIN_HEIGHT) + 15;
                sprite.position.set(labelRadius, marker.y, 0);
                sprite.scale.set(25, 3, 1);
                miScene.add(sprite);
            });
        }
        
        function createGeologicalTimeScale() {
            // Geological Eons, Eras, and Periods with their time ranges and colors
            const geologicalScale = [
                // Phanerozoic Eon (541 Ma - Present)
                { name: 'Cenozoic', startMa: 66, endMa: 0, color: 0xffff00, type: 'era' },
                { name: 'Mesozoic', startMa: 252, endMa: 66, color: 0x88ff88, type: 'era' },
                { name: 'Paleozoic', startMa: 541, endMa: 252, color: 0x88aaff, type: 'era' },
                
                // Proterozoic Eon
                { name: 'Neoproterozoic', startMa: 1000, endMa: 541, color: 0xff88aa, type: 'era' },
                { name: 'Mesoproterozoic', startMa: 1600, endMa: 1000, color: 0xcc6688, type: 'era' },
                { name: 'Paleoproterozoic', startMa: 2500, endMa: 1600, color: 0xaa4466, type: 'era' },
                
                // Archean Eon
                { name: 'Archean', startMa: 4000, endMa: 2500, color: 0x8844aa, type: 'eon' },
                
                // Hadean Eon (before life)
                { name: 'Hadean', startMa: 4600, endMa: 4000, color: 0x442266, type: 'eon' },
            ];
            
            // Position the time scale on the side
            const scaleX = -70; // Position to the left of the mountain
            const scaleZ = 0;
            const scaleWidth = 8;
            
            // Create vertical bar for each geological period
            geologicalScale.forEach(period => {
                // Convert Ma to Y position (3800 Ma = -380 Y, 0 Ma = 0 Y)
                const startY = -(period.startMa / 10);
                const endY = -(period.endMa / 10);
                
                // Clamp to mountain height
                const clampedStartY = Math.max(startY, -MI_MOUNTAIN_HEIGHT);
                const clampedEndY = Math.min(endY, 0);
                
                if (clampedStartY >= clampedEndY) return; // Skip if outside range
                
                const height = clampedEndY - clampedStartY;
                const centerY = (clampedStartY + clampedEndY) / 2;
                
                // Create the period bar
                const barGeometry = new THREE.BoxGeometry(scaleWidth, height, 3);
                const barMaterial = new THREE.MeshPhongMaterial({
                    color: period.color,
                    transparent: true,
                    opacity: 0.7,
                    emissive: period.color,
                    emissiveIntensity: 0.2
                });
                const bar = new THREE.Mesh(barGeometry, barMaterial);
                bar.position.set(scaleX, centerY, scaleZ);
                miScene.add(bar);
                
                // Add label for the period
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 64;
                
                context.fillStyle = '#ffffff';
                context.font = 'Bold 20px Arial';
                context.textAlign = 'center';
                context.fillText(period.name, 128, 40);
                
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ 
                    map: texture,
                    transparent: true
                });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.position.set(scaleX - 15, centerY, scaleZ);
                sprite.scale.set(15, 4, 1);
                miScene.add(sprite);
            });
            
            // Add main time scale axis with tick marks
            const axisX = scaleX + scaleWidth / 2 + 2;
            
            // Main vertical axis line
            const axisPoints = [
                new THREE.Vector3(axisX, 5, scaleZ),
                new THREE.Vector3(axisX, -MI_MOUNTAIN_HEIGHT - 5, scaleZ)
            ];
            const axisGeometry = new THREE.BufferGeometry().setFromPoints(axisPoints);
            const axisMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 });
            const axis = new THREE.Line(axisGeometry, axisMaterial);
            miScene.add(axis);
            
            // Add tick marks and time labels every 500 Ma
            for (let timeMa = 0; timeMa <= 4000; timeMa += 500) {
                const y = -(timeMa / 10);
                if (y < -MI_MOUNTAIN_HEIGHT) continue;
                
                // Tick mark
                const tickPoints = [
                    new THREE.Vector3(axisX, y, scaleZ),
                    new THREE.Vector3(axisX + 3, y, scaleZ)
                ];
                const tickGeometry = new THREE.BufferGeometry().setFromPoints(tickPoints);
                const tickMaterial = new THREE.LineBasicMaterial({ color: 0xffffff });
                const tick = new THREE.Line(tickGeometry, tickMaterial);
                miScene.add(tick);
                
                // Time label
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 128;
                canvas.height = 48;
                
                context.fillStyle = '#ffffff';
                context.font = 'Bold 24px Arial';
                context.textAlign = 'left';
                const label = timeMa === 0 ? 'Now' : (timeMa >= 1000 ? `${timeMa/1000} Ga` : `${timeMa} Ma`);
                context.fillText(label, 5, 32);
                
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ 
                    map: texture,
                    transparent: true
                });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.position.set(axisX + 12, y, scaleZ);
                sprite.scale.set(10, 3, 1);
                miScene.add(sprite);
            }
            
            // Add "GEOLOGICAL TIME SCALE" title at the top
            const titleCanvas = document.createElement('canvas');
            const titleContext = titleCanvas.getContext('2d');
            titleCanvas.width = 512;
            titleCanvas.height = 64;
            
            titleContext.fillStyle = '#00ffaa';
            titleContext.font = 'Bold 28px Arial';
            titleContext.textAlign = 'center';
            titleContext.fillText('GEOLOGICAL TIME SCALE', 256, 45);
            
            const titleTexture = new THREE.CanvasTexture(titleCanvas);
            const titleMaterial = new THREE.SpriteMaterial({ 
                map: titleTexture,
                transparent: true
            });
            const titleSprite = new THREE.Sprite(titleMaterial);
            titleSprite.position.set(scaleX, 15, scaleZ);
            titleSprite.scale.set(30, 4, 1);
            miScene.add(titleSprite);
        }
        
        function addMIStarfield() {
            const starGeometry = new THREE.BufferGeometry();
            const starCount = 3000;
            const positions = new Float32Array(starCount * 3);
            
            for (let i = 0; i < starCount * 3; i += 3) {
                // Distribute stars in a sphere around the scene
                const radius = 300 + Math.random() * 200;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                
                positions[i] = radius * Math.sin(phi) * Math.cos(theta);
                positions[i + 1] = radius * Math.cos(phi);
                positions[i + 2] = radius * Math.sin(phi) * Math.sin(theta);
            }
            
            starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const starMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.5,
                transparent: true,
                opacity: 0.8
            });
            
            const stars = new THREE.Points(starGeometry, starMaterial);
            miScene.add(stars);
        }
        
        function updateMINarration() {
            const narrationEl = document.getElementById('mi-narration');
            let currentNarration = null;
            
            for (const narration of MI_NARRATION) {
                if (miAnimationTime >= narration.time && miAnimationTime < narration.time + narration.duration) {
                    currentNarration = narration;
                    break;
                }
            }
            
            if (currentNarration) {
                if (narrationEl.textContent !== currentNarration.text) {
                    narrationEl.classList.remove('visible');
                    setTimeout(() => {
                        narrationEl.textContent = currentNarration.text;
                        narrationEl.classList.add('visible');
                    }, 300);
                }
            } else {
                narrationEl.classList.remove('visible');
            }
        }
        
        function updateMITimeline() {
            // Calculate current time depth based on camera position
            const progress = Math.min(1, miAnimationTime / 52000);
            
            // Animate from present to origin
            const currentY = -MI_MOUNTAIN_HEIGHT * progress;
            const currentTimeMa = 3800 * progress;
            
            const timelineEl = document.getElementById('mi-timeline-display');
            if (currentTimeMa > 1000) {
                timelineEl.textContent = `${(currentTimeMa / 1000).toFixed(1)} Billion Years Ago`;
            } else if (currentTimeMa > 1) {
                timelineEl.textContent = `${currentTimeMa.toFixed(0)} Million Years Ago`;
            } else if (currentTimeMa > 0.001) {
                timelineEl.textContent = `${(currentTimeMa * 1000).toFixed(0)} Thousand Years Ago`;
            } else {
                timelineEl.textContent = 'Present Day';
            }
        }
        
        function onMIResize() {
            if (!miCamera || !miRenderer) return;
            const container = document.getElementById('mi-animation-container');
            miCamera.aspect = container.clientWidth / container.clientHeight;
            miCamera.updateProjectionMatrix();
            miRenderer.setSize(container.clientWidth, container.clientHeight);
        }
        
        function animateMI() {
            miAnimationId = requestAnimationFrame(animateMI);
            
            if (miIsPlaying) {
                miAnimationTime += 16.67 * miAnimationSpeed; // Apply speed multiplier
            }
            
            // Camera animation - descend through time
            const progress = Math.min(1, miAnimationTime / 52000);
            
            // Spiral descent down the mountain
            const angle = progress * Math.PI * 4; // 2 full rotations
            const radius = 100 + progress * 50; // Gradually move out
            const targetY = -MI_MOUNTAIN_HEIGHT * progress + 20;
            
            // Smoothly interpolate camera position
            const targetX = Math.sin(angle) * radius;
            const targetZ = Math.cos(angle) * radius;
            
            miCamera.position.x += (targetX - miCamera.position.x) * 0.02;
            miCamera.position.y += (targetY - miCamera.position.y) * 0.02;
            miCamera.position.z += (targetZ - miCamera.position.z) * 0.02;
            
            // Look at the mountain at current depth
            const lookAtY = -MI_MOUNTAIN_HEIGHT * progress;
            miControls.target.set(0, lookAtY, 0);
            
            // Update UI
            updateMINarration();
            updateMITimeline();
            
            // Loop animation after completion
            if (miAnimationTime > 55000) {
                miAnimationTime = 0;
            }
            
            miControls.update();
            miRenderer.render(miScene, miCamera);
        }
        
        // Add click handler for title
        document.getElementById('mi-title-link').addEventListener('click', showMIMenu);
        
        // Close modals on escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeMIAnimation();
                closeMIMenu();
            }
        });

        // Start the visualization
        startVisualization();
    </script>
</body>
</html>
